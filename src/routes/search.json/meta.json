[{"title":"Home","content":"Welcome to the Modpack Dev Wiki!\n\nWelcome to the Modpack Dev Wiki, a resource for everything related to Minecraft\nDatapacks. This community-built wiki has got guides, tutorials, and\ndocumentation to help you create and modify Minecraft Datapacks.\n\nNew to Minecraft Datapacks?\n\nDon't worry! You're in the right place. We've got a guide on\nhow to make a datapack for those of you with no or\nlittle experience. If you get stuck, don't hesitate to ask in our Discord\nServer. Pages on this wiki have been written with beginners in mind - you should\nhave no trouble working through these resources.\n\nWhat are Minecraft Datapacks?\n\nMinecraft Datapacks are like addons - they are a Minecraft feature that lets you\ncustomize Minecraft worlds without mods. They allow you to modify and enhance\nthe game by adding new features and mechanics by using Minecraft commands,\nadvancements, worldgen, and more!\n\nWith datapacks, you can:\n\nAdd and modify custom recipes\nModify existing or create new loot tables\nAdd new advancements and enchantments\nCreate unique structures\nAnd much more!\n\nContribute\n\nThis project wouldn't be possible without the support of community members. We\nencourage you to contribute to this wiki if you want to write any pages, correct\nany mistakes, or share any of your knowledge!\n\nYou can hit the Edit button on any page to open the GitHub page for the\ncurrent wiki page. All our contributions are done via GitHub and are written in\nMarkdown. For more information, find the Contribution section of this page, or\nread our contribution guide on our\nGitHub repo.","description":"Welcome to the Modpack Dev Wiki, a resource for everything related to Minecraft Datapacks. We've got guides, tutorials, and documentation to help you build your knowledge about data packs.","url":"/","tags":[]},{"title":"Credits","content":"Credits\n\nThe Modpack Dev Wiki is a fork of the Datapack Wiki, managed by Datapack Hub, based\non an original design and idea by Aandeel.\n\nMade by Chemma, Emmcha, Chemkma, and Echmakyl!!","description":"The Modpack Dev Wiki is brought to you by [Datapack Hub](https://datapackhub.net) in collaboration with Aandeel.","url":"/credits/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/guide/intro-resourcepack/","tags":["intro"]},{"title":"How to Make a Minecraft Datapack - Beginner's Guide","content":"How to make a Minecraft Datapack\n\nDatapacks are a Minecraft feature that lets you customize Minecraft worlds\nwithout mods. They allow you to modify and enhance the game by adding new\nfeatures and mechanics by using Minecraft commands, advancements, worldgen, and\nmore! This guide will walk you through the process of creating your first\nMinecraft datapack from scratch in the latest version.\n\n\n\nIf you don't know what datapacks are, then take this explanation. Datapacks are\nessentially add-ons to Minecraft which can change the game, whether by adding a\nsimple game mechanic, or creating completely new experiences! The best part is\nthat they're really easy to create, even if you have little coding knowledge\n\n\n\nThis guide will help you to create your first datapack, whether you've never\ntried coding before or if you've got loads of experience. The process of coding\na datapack is a bit different to other typical programs. By the end of this\ntutorial, you'll have made a simple datapack which makes **arrows explode when\nthey land!**\n\nPrerequisites\n\nMinecraft Datapacks basically just consist of text files inside folders. For\nthis reason, you can technically make a datapack with just the default text\neditor and a file explorer. However, if you are able to, we highly suggest\ndownloading a code editor such as Visual Studio Code.\n\nWith VS Code, you will be able to view errors in your datapack, autocomplete\ncommands, and highlight syntax with different colours so that making datapacks\nisn't as painful as using Notepad.\n\nDownload Visual Studio Code: https://code.visualstudio.com/download\nGet the VS Code extensions for datapack development:\nhttps://marketplace.visualstudio.com/items?itemName=amandin.dpc-pack\n\n\n\nIf you prefer not to download programs, then you can use a web version of Visual\nStudio Code which essentially has all the same features, except it can be slower\nor more difficult to work with. https://vscode.dev/\n\n\n\nSetting up an empty datapack\n\nThe first step when creating a datapack is to make a new world to test it\nin. Go ahead and do that now - make sure that your world has cheats enabled\nand it is set to creative mode. In the world, you will need to run the /datapack create command - \nit will create your datapack folder as well as the necessary metadata for you, which saves you a bunch of time.\n\nFor example, to make a datapack with the ID ExampleDatapack and the\ndescription \"This is an example datapack\", you would run the following command:\n\n/datapack create ExampleDatapack \"This is an example datapack\"\n\nOnce you've created your empty datapack, the next step is to find and open the\nworld folder:\n\nSave and quit your world\nGo to your world in the Singleplayer menu and hit \"Edit\"\nPress \"Open World Folder\"\n\nThe folder that opens contains your Minecraft world's data. There will be loads of subfolders in\nthis folder: find the one which is called datapacks, and open it. This folder is where the world's datapacks are stored. If you used /datapack create, you should see your datapack's folder here already. (If not, you'll have to create it yourself. This is explained in the \"NOTE\" box below)\n\n\n\nIf you are using Visual Studio Code, at this point you should open it, find\nOpen Folder, and open the newly created folder. Navigating through your\ndatapack will be so much easier!\nopen folder location\n\n\n\nThe datapack folder will contain pack.mcmeta and a folder called data.\npack.mcmeta tells Minecraft that the folder is a datapack, \nas well as containing the basic information about the pack, such \nas what versions it works in. /datapack create made this file automatically, but you can open the file like normal and view it if you want:\n\n{\n\"pack\": {\n\"description\": \"This is an example datapack\",\n\"pack_format\": 88\n}\n}\n\nIf you're interested, here's what this file means:\n\npack is an object containing the metadata of the file.\ndescription is the name of your datapack, usually along with a short\ndescription of what your pack does.\npack_format tells Minecraft what versions this datapack works in. 88\n(or 88.0) is the latest for 1.21.10\n\n\n\n\n\nIf you're in a version earlier than 1.21.6, you may notice that /datapack create doesn't \nexist. You will have to create your datapack folder (inside datapacks) yourself. Just make\na folder, and then inside that folder, create pack.mcmeta (as shown above) and the data folder.\n\n\n\nWriting your first function\n\n\n\nWhat are functions? In short, functions are the majority of what makes up most\ndatapacks. A function is a file containing Minecraft commands. When a function\nis ran, every command in the function is ran in order. Functions are always ran\nas an entity (or as the Server) and at a position\n\n\n\nLet's get started by writing one simple function. In traditional programming\nfashion, let's make a function which sends \"Hello World\" to chat.\n\nOpen your empty data folder.\nIn the data folder, create a new folder. This folder is your\nnamespace - it will contain all the data specific to your datapack.\nUsually this needs to have a unique name (one which other people would\nnot have picked), but for this tutorial just call it example.\nIn the example folder, create a folder called function. This folder will\ncontain all the .mcfunction files.\n\nYou should now have a folder structure that looks something like this:\n\n/world/datapacks/ExampleDatapack/data/example/function\n\n\n\nIn versions earlier than 1.21, the function folder should be called functions,\ndue to some pesky name changes Mojang introduced in a recent update.\n\n\n\nOnce you're sure that's correct, you can start writing the actual function.\n\nIn the function folder, create an empty text file called hello_world.mcfunction.\nOpen this file with any text editor (we recommend Visual Studio Code)\n\nInside hello_world.mcfunction, put the following:\n\nShow the player Hello World on their screen\ntitle @s title \"Hello World!\"\n\nGive the player a diamond\ngive @s diamond\n\n\n\nCommands in functions shouldn't have the default slash / symbol which in-world\ncommands have! Having the / before a command will make the mcfunction invalid\nand fail when it tries to run\n\n\n\nIt's that simple! Once you save that file, and then run /reload (or if that doesn't work, rejoin your world), you should be able to use the following command to run the function:\n\n/function example:hello_world\n\nWhat's next?\n\nNow you know how to create a basic function and run it, we'll next start to\nthink about how to create our project. For more advanced projects, this can\nsometimes be the most difficult part. Luckily for us, what we want to create\nwon't be too difficult.\n\nLet's break down the idea into smaller steps. Remember, we want to create a\ndatapack which makes arrows explode.\n\nDetect when an arrow lands on the ground. We can do this by running a\ncommand on a loop which will select any arrow on the ground and then run a\nfunction.\nCreate an explosion. This is as simple as summoning a TNT at the position\nof the arrow.\nRemove the arrow. If you don't do this, then it will keep on exploding\nforever.\n\nThe next steps of this guide will guide you through the typical process of each\nof those steps.\n\nRunning functions on a loop\n\nThe first step on our list is to detect arrows which land on the ground. To do\nthis, we need to run a command on a loop. Luckily, Minecraft makes this pretty\neasy for us.\n\nFirstly, let's make the function which you want to run on a loop. In the\nfunction folder, create a new mcfunction file - call this one\nloop.mcfunction.\n\nFor now, let's just make it say \"Hi\" every time it loops. You can do this by\nputting this in the new function:\n\nsay Hi\n\nTo make this function run on a loop, we need to create a JSON file which tells\nMinecraft \"run this command every tick\" (every tick = 20 times per second)\n\nIn the data folder, create the minecraft folder.\nIn the minecraft folder, create a tags folder\nIn the tags folder, create a function folder\nIn the new function folder, create a new text file: tick.json\n\nThe final path would look like this:\n/world/datapacks/ExampleDatapack/data/minecraft/tags/function/tick.json\n\ntick.json is NOT a function. In tick.json, we are going to put a **list\nof functions** which we want to run every tick. If you put any commands in\ntick.json, it will break your pack.\n\nIn tick.json, put the following:\n\n{\n\"values\": \"example:loop\"]\n}\n\nvalues is a list of function references which will be run on a loop.\nexample:loop is a reference to the loop.mcfunction file we created\nearlier. example refers to the namespace (the folder in data), and loop\nrefers to the mcfunction file name.\n\nIf you save this file, go back to your world, and run /reload, you should see\nthat the chat is being spammed with \"Hi\" over and over again!\n\nSelecting the arrows\n\nNow we've created a function which will run infinitely on a loop, we can move on\nto detecting when an arrow is in the ground.\n\nAs far as the game is concerned, an arrow is an entity, just like a pig, cow\nor zombie. Minecraft gives us a special way to select any types of entities\nwith [target selectors. Once we've selected an\nentity, we can use the /execute command to run a\ncommand as the entity.\n\nWe can use these to select all arrows which are in the ground, and then run a\ncommand to make them explode (and then remove themselves).\n\nAs mentioned, to select an entity, we need to use a target selectors. I'm going\nto teach you a bit about target selectors. You should pay attention here, but if\nyou only want the code, scroll past this section.\n\nWhat are target selectors?\n\nTarget selectors are a special bit of code we can use to find an entity in the\nworld. They all start with an @ symbol. There are 6 base target selectors:\n\n| Target Selector | Description|\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| @e| All Entities - By itself, this selector will select every single entity which is currently loaded in the world.|\n| @s| This Entity - This selector will select the entity which is currently running the command. For example, if I run a command as @s, then it will run the commands as me. |\n| @a| All Players - This selects all currently online players. (All players are always loaded in the world).|\n| @r| Random Player - This selects one random player.|\n| @p| Nearest Player - This selects the nearest player to the position this command is ran from.|\n| @n| Nearest Entity - This selects the nearest entity (player or non-player) to the position this command is ran from.|\n\nOn it's own, a base target selector (like in the table) does not do much. We can\nnarrow down the selection even more by using criteria. Criteria are put in\nsquare brackets after the base selector.\n\nFor example, we can use @e with a type criteria to select all entities of a\ncertain type - for example, @etype=minecraft:cow] would select all cow\nentities.\n\nI'm not going to explain every single criteria you can use - you can view a list\n[here. These are the\nbasic ones which you might see quite often:\n\n| Criteria| Description|\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [type=minecraft:arrow] | Entity Type - This criteria will narrow down the selection to only include entities of a certain type. For good pack optimisation, you should use this often.|\n| [distance=..5]| Distance to entity - This criteria will only include entities based on their distance to their distance to the current position. .. can be used to represent a greater/less than symbol - for example, ..5 means less than 5 blocks away.|\n| [limit=2]| Limit selection - Using the limit criteria, you can make specify a max amount of entities to be selected. This is often used in conjunction with the sort criteria. For example, @e[sort=nearest,limit=1] would select the nearest entity of any type. |\n| [nbt={key:value}]| Entity Data - This criteria will select entities if their NBT (entity data) matches a pattern. (note: if you do this loads of times, it might start to be a bit laggy!) |\n\nHow are we going to use them?\n\nWe can use these selectors to only select arrows which are in the ground. We can\nselect all arrows with @e[type=arrow], but this will also include arrows in\nthe air. To select arrows in the ground, we can check if they have the data\n{inGround:1b}, so we would use @e[type=arrow,nbt={inGround:1b}]\n\nThis target selector can be used in an execute command to run a command as the\nentity. Try putting this in your loop.mcfunction:\n\nexecute as @e[type=arrow,nbt={inGround:1b}] run say I'm an arrow, I'm in the ground!\n\n/reload your datapack and fire an arrow at at a block. You should see that your\nchat is spammed with messages, meaning that we successfully selected arrows in\nthe ground, and executed a command as them!\n\nMake it go boom\n\nNow we can move onto the fun part! We have a simple command which will run\nanother command as any arrow in the ground. We only need to do two things with\nthis command:\n\nGet the arrow's position\nSpawn an explosion at the position of the arrow\nKill the arrow so that it only explodes once\n\nTo create an explosion in Minecraft, we can simply summon a TNT entity that has an instant fuse length - we can do this by summoning tnt with the data {fuse:0} at the position of the arrow. We can do this using the execute at command, which tells the game that the summon command should be ran at the position of the entity, instead of at the world spawn (because all commands are run at a position in the world). This way, when we summon an entity at~, the game knows that it's referring to the position of the arrow. This sounds complicated, but in reality, its a really easy and intuitive system when you understand it :P\n\nexecute at @e[type=arrow,nbt={inGround:1b}] run summon tnt~ {fuse:0}\n\nThen, we just need to copy this command and make it kill the arrow after the\nexplosion has happened. This is as simple as it sounds - we can use /kill to\nremove the arrow. Your finished loop.mcfunction should look like this:\n\nexecute as @e[type=arrow,nbt={inGround:1b}] at @s run summon tnt~ {fuse:0}\nkill @e[type=arrow,nbt={inGround:1b}]\n\n\n\nIn reality, this method might be a bit laggy if there are a lot of arrows in the world. A better system would involve creating a function which referenced @s (the \"current\" entity) instead of @e[...], and then runnning that function as all arrows in the ground. This way, we only use @e[...] once, which is a lot more efficient. However, for the purposes of this tutorial, it doesn't matter at all.\n\n\n\nYou're done! Once you /reload your pack, you should be free to play around\nwith a simple exploding arrows datapack which you made with the help of this\ntutorial. Take a break to play around with it - you deserve one!\n\nAnd when you want to move on to other datapack ideas you might have, feel free\nto join our Discord server for extra support from our team of helpers. We're\nmore than happy to help you on your journey to creating awesome Minecraft\ndatapacks!","description":"Learn how to create a Minecraft datapack with our beginner's guide. This step-by-step tutorial will help you understand the basics of datapack creation, even if you have little coding knowledge. Start enhancing your Minecraft experience today!","url":"/guide/getting-started/","tags":["guide","beginner","Minecraft","datapack","tutorial","step-by-step"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/guide/intro-datapack/","tags":["intro"]},{"title":"Adding biomes to your modpack","content":"Adding Biomes","description":"Adding custom biomes to the game","url":"/guide/worldgen/modifying-biomes/adding-biomes/","tags":["guide","worldgen","biomes","datapack","tutorial","lithostitched"]},{"title":"Removing biomes from your modpack","content":"Removing Biomes","description":"Removing biomes from the game","url":"/guide/worldgen/modifying-biomes/removing-biomes/","tags":["guide","worldgen","biomes","datapack","tutorial","lithostitched"]},{"title":"Removing features from your modpack","content":"Removing worldgen features\n\nRemoving worldgen features is most easily done through worldgen modifiers, such as those provided through Lithostitched. More information on Lithostitched Worldgen Modifiers can be found on their wiki, and can be created using their generator site.\n\nExample worldgen modifier\nRemoves Copper Ore generation from the Overworld.\nin data/remove_ores/lithostitched/worldgen_modifier/remove_copper.json\n{\n\"type\": \"lithostitched:remove_features\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"features\": \n\"minecraft:ore_copper\",\n\"minecraft:ore_copper_large\"\n]\n}\n\n\n\nBiome modifiers are also possible through [Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n","description":"Removing worldgen features to your game with datapacks and Lithostitched","url":"/guide/worldgen/modifying-features/removing-features/","tags":["guide","worldgen","features","datapack","tutorial","lithostitched"]},{"title":"Adding worldgen features to your modpack","content":"Adding worldgen features\n\nFeatures need three things to generate in your world:\nConfigured Feature: Determines the type and parameters of the feature you want to generate.\nPlaced Feature: Determines where a Configured Feature should be attempted to be placed using placement modifiers.\nWorldgen modifier: Determines what biomes the Placed Feature can generate in. Implemented through Lithostitched.\n\nConfigured features consist of a type and a config field, where type is the kind of feature generated, and config is any customization for the feature. Available config values depend on what the feature type is. For vanilla feature types, you can use Misode's Configured Feature Generator to easily create feature files. For more information on feature types and configs, see the Minecraft Configured Feature Wiki.\n\nExample Configured Feature:\nin data/amethyst_ore/worldgen/configured_feature/amethyst_configured.json\nDefines a feature that replaces minecraft:stone with an ore feature using minecraft:amethyst, with a size of 8\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"targets\": \n{\n\"target\": {\n\"predicate_type\": \"minecraft:block_match\",\n\"block\": \"minecraft:stone\"\n},\n\"state\": {\n\"Name\": \"minecraft:amethyst_block\"\n}\n}\n],\n\"size\": 8,\n\"discard_chance_on_air_exposure\": 0\n}\n}\n\nPlaced features consist of feature and placement parameters. The feature parameter references a Configured Feature ID, while the placement parameters define where in a biome the feature can spawn. Again, you can use Misode's [Placed Feature Generator to assist in making feature files, and see the Minecraft Placed Feature Wiki for more information on placement parameters.\n\nExample Placed Feature:\nin data/amethyst_ore/worldgen/placed_feature/amethyst_placed.json\nPlaces the amethyst_ore:amethyst_configured feature between y=-20 and y=60, with a count multiplier of 32\n{\n\"feature\": \"amethyst_ore:amethyst_configured\",\n\"placement\": \n{\n\"type\": \"minecraft:count\",\n\"count\": 32\n},\n{\n\"type\": \"minecraft:in_square\"\n},\n{\n\"type\": \"minecraft:height_range\",\n\"height\": {\n\"type\": \"minecraft:uniform\",\n\"min_inclusive\": {\n\"absolute\": -20\n},\n\"max_inclusive\": {\n\"absolute\": 60\n}\n}\n},\n{\n\"type\": \"minecraft:biome\"\n}\n]\n}\n\nLithostitched Worldgen Modifiersconsist of type, biomes, features, and step parameters. type defines what action the modifier will do, biomes consist of a string or array of biome or biome tag IDs, features consist of a string or array of feature or feature tag IDs, and the step parameter defines what phase of worldgen the feature will generate in. More details on worldgen modifiers from [Lithostitched can be found on their wiki. Additionally, Lithostitched has a generator site similar to Misode to aid in production of files.\n\nExample Biome Modifier using Lithostitched:\nin data/amethyst_ore/lithostitched/worldgen_modifier/add_amethyst.json\nAdds the amethyst_ore:amethyst_placed placed feature into all biomes with the #minecraft:is_overworld tag\n{\n\"type\": \"lithostitched:add_features\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"features\": \"amethyst_ore:amethyst_placed\",\n\"step\": \"underground_ores\"\n}\n\n\n\nBiome and Biome Tag IDs can be found by going through /locate biome in-game, and using the arrow keys to navigate\nCommonly used biome tags can be found here\nIf KubeJS is installed, you have a variety of options of dumping registries into your latest.log. Run /kubejs dump_registry minecraft:worldgen/... in-game to see the available options.\n\n\n\n\n\nBiome modifiers are also possible through Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n","description":"Adding worldgen features to your game with datapacks and Lithostitched","url":"/guide/worldgen/modifying-features/adding-features/","tags":["guide","worldgen","features","datapack","tutorial","lithostitched"]},{"title":"Modifying mob spawns","content":"Editing mob spawns\n\nThere are several methods to edit mob spawns, each with varying levels of complexity and control, with the main ones being:\n\nLithostitched - Simplest of the three, allows for basic worldgen modifiers to edit spawns\nIn Control! - Spawn control with extremely verbose JSON\nKubeJS - skript dat shit bay bee!\n\nWith Lithostitched\n\nLithostitched can edit mob spawns a datapack adding a worldgen modifier. You have the option of either adding or removing spawns from biomes. Some examples pulled directly from the Lithostitched wiki are found below.\n\nAdding spawns:\nin data/edit_spawns/lithostitched/worldgen_modifier/add_witches.json\nAdds witch spawns to swamps\n{\n\"type\": \"lithostitched:add_biome_spawns\",\n\"biomes\": \"#c:swamp\",\n\"spawners\": {\n\"type\": \"minecraft:witch\",\n\"weight\": 450,\n\"minCount\": 3,\n\"maxCount\": 3\n}\n}\n\nRemoving spawns:\nin data/edit_spawns/lithostitched/worldgen_modifier/remove_zombies.json\nRemoves zombie spawns from the overworld\n{\n\"type\": \"lithostitched:remove_biome_spawns\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"mobs\": \"minecraft:zombie\"\n}\n\nThese modifiers can be generated through the Lithostitched generator site.\n\n\n\nBiome modifiers are also possible through Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n\n\nIn Control!\n\nIn Control! uses extremely verbose JSON syntax to edit spawns, and is very useful if you'd like more control over spawns than simply adding mobs to the spawn pool. Additional features over Lithostitched includes, but is not limited to:\n\nGame Stages integration\nAdding gear/NBT to mobs\nY-level control\nDay counter control\nWeather control\n\nWhile it does have a wiki, it is hard to follow at times, and does not include many tangible examples. \n\n\n\nIn Control is not available on Fabric.\n\n\n\n\\\n\nKubeJS\n\nliterally noone knows how tf this works at all bruuu","description":"Guide on modifying mob spawns with various methods","url":"/guide/mob-spawns/","tags":["mobs","lithostitched","guide","incontrol","kubejs"]},{"title":"Introduction to modpack development","content":"Introduction to modpack development\n\nThis article is not written yet...","description":"placeholder","url":"/guide/intro-intro/","tags":["intro"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/useful-tags/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/version-control-tools/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/regex/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/mcmeta-filtering/","tags":[]},{"title":"Adding biomes to your modpack","content":"Free multiplayer options for modded Minecraft\n\n| Mod| Versions| Pros | Cons| Additional notes |\n| ----------------------------------------------------------------------- | ----------------- | ---- | ------------------ | ---------------- |\n| e4mc| 1.17 -> 1.21.11|| Reliability issues ||\n| Cloudflared | 1.7.10 -> 1.20.4||||\n| Tunnely| 1.19.2 -> 1.21.10 ||||\n\nOracle Free Tier is a service offered by the Oracle corporation to offer free 24GB servers to users who apply. The catch is that it's more time and effort to set up and maintain than any of the mods shown here, since you'd be setting up an unmanaged Linux server to play Minecraft from scratch. However, some online guides do exist to aid through the process.\n\nIf you are already an established developer in the community, you may want to consider looking into a server sponsor partner. Sponsors often give out servers to their partners for free, and most elegible creators could find themselves getting a 6-8GB server out of a partnership.","description":"Exploring options for free multiplayer in modded Minecraft","url":"/wiki/info/free-multiplayer/","tags":["info","multiplayer","free","server"]},{"title":"Custom World Generation","content":"Custom World Generation\n\nCustom World Generation is an experimental feature, allowing a data pack to\ngenerate custom features, biomes, or dimensions, primarily by way of a series of\nJSON files rather than by using commands.\n\nThis guide goes over how to create every step of a custom dimension, which\nitself comprises all of the following. If you only want to achieve one or some\nof these things, you can generally skip to those respective sections.\n\nModifying and defining dimension settings\nGenerating terrain\nCreating biomes\nArranging biomes\nCreating features (ores, trees, etc.)\nMany sub-tasks related to the above\n\nAt the same time, this documentation will express some of the major limitations\nthat come with Custom World Generation. There are many aspects of worldgen that\nwe will go over here in brief, but that could fill entire guides of their own to\nexplore in detail. Many of the tasks involved in creating Custom World\nGeneration can be extremely time-intensive and require a lot of trial and error.\n\nWhat is Custom World Generation?\n\nCustom Worldgen can take the form of anything from a completely separate\ndimension, an override of vanilla dimensions or biomes, like the Overworld at\nlarge or Swamps in particular, or individual features that are placed via\ncommands. The following are all things that Custom World Generation can include,\nirrespective of difficulty.\n\nCustom Terrain\nCustom Dimension Settings, such as:\nUltrawarm\nPiglin zombification\nRespawn Anchors vs Beds\nLight level\nDaylight cycle (on/off)\netc.\nCustom Biomes (Surface and Cave)\nNatural features (Trees, ores, flowers, etc.)\nCustom colors and ambient particles\nCustom Biome layout (including of vanilla biomes)\n\nCustom Structures, and changes related to structures, are also a sub-feature of\nCustom World Generation. We already have documentation for creating Custom\nStructures, which you can find\nhere.\n\nFolder Structure\n\nTo begin creating a Custom Dimension, there are a few folders you should create\nin a data pack. If you’re unfamiliar with the general structure of a data pack,\nyou should check out our Data Pack Starter Guide.\n\nIn your namespace folder, you will create the following folders, organized as\nsuch:\n\n/\n├── dimension/\n├── dimension_type/\n└── worldgen/\n├── biome/\n├── configured_carver/\n├── configured_feature/\n├── density_function/\n├── noise/\n├── noise_settings/\n└── placed_feature/\n\nYou may not need all of these folders depending on the degree of configurability\nyou want or the scope of your project, so which folders are needed or optional\nfor any particular task will be listed at the top of each section.\n\nBecause Custom World Generation requires so many different JSON files, many with\na variety of required vs. optional fields, it is strongly recommended that you\ngenerate most or all of these files using\nMisode’s generators. Furthermore, frequent\nreference to the wiki pages for\ncustom dimensions and their respective subcategories will likely be necessary,\nif only to determine what type of data some fields are expecting, when Misode or\nthis guide do not specify.\n\n\n\nSome popular VSCode extensions may falsely inform you that certain files you\nreference don’t exist or are in the wrong folder, when in fact they are,\ndepending on the version you are working in. This is most common for\nconfigured_features, but be on the lookout for this behavior elsewhere.\n\n\n\nDimension Type\n\nFolders: dimension_type\n\nWhen creating a new dimension, or modifying an existing one, it’s recommended to\nstart with the Dimension Type. The Dimension Type is what defines the very broad\ndetails about the dimension, such as whether water evaporates instantly like the\nNether (Ultrawarm), whether Beds and/or Respawn Anchors work or explode, and\nwhat light level Hostile Mobs need to spawn. Most of these fields are self\nexplanatory, and most of them are required.\n\ndimension_type/overworld.json\n\n{\n\"ambient_light\": 0.0,\n\"bed_works\": true,\n\"coordinate_scale\": 1.0,\n\"effects\": \"minecraft:overworld\",\n\"has_ceiling\": false,\n\"has_raids\": true,\n\"has_skylight\": true,\n\"height\": 384,\n\"infiniburn\": \"#minecraft:infiniburn_overworld\",\n\"logical_height\": 384,\n\"min_y\": -64,\n\"monster_spawn_block_light_limit\": 0,\n\"monster_spawn_light_level\": {\n\"type\": \"minecraft:uniform\",\n\"max_inclusive\": 7,\n\"min_inclusive\": 0\n},\n\"natural\": true,\n\"piglin_safe\": false,\n\"respawn_anchor_works\": false,\n\"ultrawarm\": false\n}\n\nTo create this, simply add a .json file to the dimension_type folder, and set\nthe name to that of the dimension you are creating/modifying. Like all file\nnames, it must have no capital letters, and no special characters except\nunderscores. Then generate the list of fields with\nMisode.\n\nNote that some fields, like “has ceiling”, don’t do what you would expect – this\nfield doesn’t actually give the dimension a physical ceiling, that’s handled in\nthe terrain. Similarly, “Effects” pretty much just changes the skybox and\ndetermines whether the time affects the light level.\n\nNoise Settings\n\nFolders: noise_settings\nOptional Folders: density_function, noise\n\nThe Noise Settings are one of the largest files you will create. This single\nfile per dimension controls all of the following:\n\nWhat base block the dimension’s terrain is made of (Stone, Netherrack, etc.)\nWhat base fluid is used for the sea level (Water, Lava, etc. Does not need to\nbe a fluid)\nSome global settings, such as:\nWhether “Creatures” (passive mobs) spawn during chunk generation\nBiome noise parameters that the worldspawn is allowed to be set in during\nworld creation\nWhether large ore veins generate, and their general size and shape via\nDensity Functions. Only applies to Copper and Iron veins\nWhether aquifers generate. Not configurable beyond true/false. If false,\nmost caves below sea level will be filled with the base fluid.\nNoise Router (The shape of the terrain, which is determined by a few further\nfields)\nSurface Rules (What blocks the surface is made up of, typically broken down by\nbiome)\n\nNote that the sea level also determines the level that caves become filled with\nLava, so a higher sea level will also raise the cave Lava level, and a deeper\nworld with a default sea level will result in all caves being filled with lava\nbelow the same point (about Y=-50).\n\nNoise Router (Terrain)\n\nThe Noise Router is responsible for most factors relating to the terrain, which\nis to say, whether a given block is air/fluid or the default_block, before\nsurface_rules or biome features are added. In addition, the Noise Router\nincludes several fields that don’t directly influence the terrain, but may\napproximate it for use in making biome distribution conform to the terrain.\n\nThe Noise Router contains several fields. All of these fields are density\nfunctions, which can be defined in-line or referenced from the density_function\nfolder. These are essentially formulas of variable length and complexity, that\nuse a variety of functions to determine a value between 0 and 1 for every\ncoordinate. For density functions that affect terrain, this determines whether\nthe block is air/fluid (respecting sea level), or the default_block,\nrespectively.\n\nLet’s look at what each of these density functions are responsible for.\n\nbarrier, fluid_level_floodedness, fluid_level_spread\n\nThese all relate to some facet of Aquifer generation, if they are enabled.\n\nlava\n\nUsed to determine whether an aquifer is lava or not. Does not affect the lava\nthat floods the bottom of the world.\n\nvein_toggle, vein_ridged, vein_gap\n\nUsed to control the shape, density, and rarity of both Iron and Copper Large Ore\nVeins. Cannot change what these blocks are made of, but whether the vein is\nCopper or Iron is based on the vein_toggle noise range.\n\ntemperature, vegetation\n\nCorrespond to the “temperature,” and “humidity,” parameters in the dimension’s\nbiome source, respectively. Ostensibly create the noise maps that biomes are\nplaced relative to. These density functions don’t affect terrain at all.\n\ncontinents, erosion, depth, ridges\n\nCorrespond to the “continentalness,” “erosion,” “depth”, and \"weirdness\"\nparameters in the dimension’s biome source, respectively. Like the temperature\nand vegetation density functions, whatever is put in these fields will not\ndirectly affect terrain, and ostensibly just create noise maps for the biome\nsource to use. However, in the vanilla overworld, these fields are used to\nreference separate density function files that also get referenced elsewhere, to\ninform the terrain. This means that unlike the temperate and vegetation density\nfunctions, these correspond to certain parts of the terrain.\n\nFor example, high erosion parameter values match up with where the terrain is\nmore flat, because of how it gets referenced by other density functions that\nimpact terrain.\n\n\n\nTemperature and vegetation are also all capable of behaving more like\ncontinents, erosion, and depth, but it’s generally not necessary to have so many\nparameters that conform to terrain, and can in fact make biome distribution\nharder and more time consuming.\n\n\n\ninitial_density_without_jaggedness\n\nUsed for aquifers and surface_rules, in order to more accurately determine where\nthe surface of the world is so that neither can generate above that surface.\nTypically, will be similar to the final_density, but with the surface slightly\nlowered, and with noise caves unaccounted for. Similar to the above few\nfunctions, it does not affect terrain at all.\n\nfinal_density\n\nThis is the density function that actually creates the bulk of the terrain. As\nsuch, it’s often the largest and most complex part of the noise_settings file,\nbarring surface_rules. It controls not only the surface, including hills,\nmountains, valleys, and oceans, but also the large noise caves and noodle caves\nintroduced in the Caves and Cliffs update. And, as alluded to above, you still\nneed at least the continents and erosion density functions to align with the\ngeneral shape of this density function if you plan to have ocean biomes generate\nonly where the terrain dips below sea level, or mountain biomes generate only\nwhere the terrain spikes up to look like mountains.\n\nIn the\nvanilla Overworld,\nthe final_density is split into two distinct parts: The part that handles the\nshape of the surface, including mountains, hills, rivers, and oceans; and the\npart that handles the large noise caves underground. These are separated by an\nin-line range_choice density function.\n\nDensity functions are very complex, and being very math-heavy, difficult to dive\ninto and learn about; an in-depth understanding of them and how to apply them is\noutside the scope of this guide. Generally, a lot of trial and error is\nrequired, and there are minimal resources for getting particularly good at\napplying them. These are primarily\nthe wiki page which lists them all\nand what they do to the inputs/arguments,\nthis brief tutorial\nwritten by Misode and now hosted on the wiki, which explains how the Final\nDensity affects the terrain, and provides some basic steps to manipulate it, and\nof course\nMisode’s generator to help\nvisualize individual density functions or chains of them. However, as a brief\nintroduction, this guide will attempt to describe, roughly, how the vanilla\noverworld's final_density applies important density functions to shape the\nworld's surface.\n\nsloped_cheese\n\nUsed as the input in the aforementioned range_choice density function to\ndistinguish between the surface and underground (for noise caves), as well as\nthe main density function that gets applied to the surface. It multiplies the\ndepth and the jaggedness density functions with the factor density function,\ncombining the various shapes they create into one coherent surface shape.\n\nfactor\n\nContains a complex spline that functionally combines the continents, erosion,\nand ridges_folded density functions. These three on their own are ostensibly\nnoise maps like temperature and vegetation, but this spline translates them into\nterrain. Continents is used to create a transition between high and low terrain,\nwith erosion added to flatten the terrain, and ridges_folded (which just\nreferences ridges with some multipliers) to carve rivers or raise peaks on\nmountains.\n\ndepth\n\nCreates a gradient from the surface of the world down, where the surface and\neverything above it is assigned a value of 0, and ascends towards 1 as the world\nheight decreases. It gets the coordinates of the surface by referencing the\noffset density function.\n\noffset\n\nSimilar to factor, and uses the continents, erosion, and ridges_folded density\nfunctions in a similar way to create a shape similar to the terrain's surface,\nbut slightly offset so that the depth density function doesn't start the\ngradient until a little below the surface (generally).\n\njaggedness\n\nSimilar to factor, and uses the continents, erosion, and ridges_folded density\nfunctions in a similar way to create a more jagged version of the surface shape.\nThis gets diluted some due to being combined with both offset and factor higher\nup the chain, but results in some hills populating flatter areas, which also\nhelps to break up otherwise smooth or flat mountains so they look more natural\nand rolling.\n\nSurface Rules\n\nSurface Rules are what add the surface layers to terrain. This is\nhighly-configurable, but at its most basic level, it’s what decides that the\nground in Forests is made up of Grass Blocks and Dirt, and that Deserts have\nSand and Sandstone. Surface Rules can also allow for different blocks to make up\nthe ground depending on height, steepness, or even based on random noise.\n\nNotably, the Surface Rule also places the Bedrock on the bottom (or top) of the\nworld, and handles the transition from Stone to Deepslate at Y=0. This means\nboth of these features can be edited or removed, and in fact it’s fairly easy to\ndo so compared to handling the actual surface.\n\nCreating surface rules is relatively easy. You’ll start with something like this\nin your Noise Settings:\n\n{\n\"surface_rule\": {\n\"type\": \"minecraft:sequence\",\n\"sequence\": ]\n}\n}\n\nInside the sequence brackets, you can add yet more objects. There are four\ndifferent types:\n\nSequence: Allows you to add a new nested list. Generally, it’s good\npractice to nest sequences inside of a condition that will apply to multiple\nchild conditions or blocks.\nBlock: Defines the block that gets placed. Usually used at the end of a\nseries of conditions.\nBandlands: Not a typo. Just places the hardcoded Badlands terracotta\npattern, and doesn’t have any additional fields.\nCondition: This is the most prominent part of Surface Rules. There are\nmultiple kinds of conditions, including biome, Y level, steep, and more.\nRegardless of the condition you select, it will always have the additional\nfield “then run”, which just accepts another object type from the above list.\n\nYou may find yourself using combinations of conditions, with or without\nsequences, to get a satisfying surface. This guide won't go over every surface\nrule condition, but here are some common ones and how they are often used.\n\nabove_preliminary_surface\n\nUses the initial_density_without_jaggedness density function to determine where\nthe surface of the world is. Not using this would just mean that the surface\nrule would apply in noise caves as well. If you’re not using an\ninitial_density_without_jaggedness density function, there’s no other real harm\nin choosing not to use this condition.\n\nstone_depth\n\nThis condition finds the blocks that are actually on the surface via heightmap,\nignoring water, and works even if there was no preliminary surface condition\nused. This is one of the most common conditions, in that every dimension will\nuse it, but it is also a fairly resource-intensive condition, and the one most\nlikely to cause chunk generation lag. It’s best to use it minimally, as high up\nin the Surface Rule as you can. Oftentimes, you will need at least two of these:\nOne for the top surface, and one for the secondary surface.\n\nwater\n\nCan be used to have its child conditions apply based on the fluid level at that\nlocation, including not being in fluid. The vanilla Overworld surface rule uses\nthis a lot, and it’s a great way to alleviate the impact of an earlier\nstone_depth condition.\n\nbiome\n\nSpecifies which biome(s) to apply the rest of the rule to.\n\ny_above\n\nCauses the rest of the rule to only apply to blocks above the specified Y value.\nYou can add an optional multiplier for this value, or choose to add the\nstone_depth from previous conditions to this calculation.\n\nIt’s best to look at how the Overworld’s surface rule uses combinations of\nconditions to produce a surface of, for example, Grass Blocks with 2-4 layers of\nDirt underneath. The vanilla Overworld Surface Rule is not as extreme as the\nvanilla Overworld Dimension file (up next), but it is a little more lengthy and\nsophisticated than can reasonably be pasted here.\n[Misode’s generator has a\nfeature to view the vanilla Overworld Noise Settings as a preset, which includes\nthe Surface Rule; this may be useful to get a more user-friendly view of how the\nconditions fit together.\n\nDimension\n\nFolders: dimension\n\nThe Dimension file is where you reference both the Dimension Type and Noise\nSettings you would like this dimension to use by their namespaced ID. The name\nof this file is also what will become the namespaced ID of this dimension for\ncommands such as /execute in, regardless of the names of the noise_settings or\ndimension_type files referenced. Lastly, this is where you will list all of the\nbiomes you want to appear in the world, using parameters to define which biomes\ncan appear where on several noise maps.\n\nBiome Source\n\nBesides Terrain, the Biome Source is where you may find yourself spending the\nmost time. It is highly configurable, and has the potential to integrate with\nthe Continents and Erosion density functions defined in the Noise Router to help\nplace biomes in a way that appears to conform to the terrain (Mountain biomes on\nelevated terrain, Plains biomes on flatter terrain, etc.). Biome Layout is much\nmore approachable than terrain in terms of configurability, but making them work\nhand-in-hand in this way can be time consuming.\n\nTo put things in perspective, you may have noticed above that the vanilla\nOverworld’s Dimension file is over 200,000 lines long. Every biome has dozens of\nrepeat entries, each with slightly different parameters to get the biome\ndistribution and terrain conformity just right. This is because the six primary\nparameters (temperature, humidity, continentalness, erosion, and depth)\nbasically work to create a 6-dimension noise map. Making a biome source that\nplaces biomes according to terrain by hand is borderline impossible, and indeed,\nthis file gets generated by the game using a system similar to\nSnowcapped, a tool by jacobsjo that uses\ngrids to simplify the visualization of a 6D grid.\n\nThe Nether is far easier to work with and add new biomes to, as those biomes do\nnot conform to the terrain, and each vanilla biome has only one entry.\n\nThe End’s biome source is hardcoded; this is because Mojang needs to ensure that\nthe central End Island is always the default “minecraft:the_end” biome, which\ncannot be guaranteed with current tools. However, if you don’t mind making the\ncentral End Island a different biome, you can approach a custom biome layout\nsimilarly to how you would the Nether.\n\nFor a custom dimension, the complexity is up to you. If you aim to have your\nbiomes conform to terrain, then you may end up with a biome layout of comparable\ncomplexity and time commitment to the vanilla Overworld’s. If not, then it’s\njust a matter of determining which biomes you do or do not want to appear next\nto each other, and then setting the parameters appropriately.\n\nEach entry in the “biomes” list should look something like this:\n\n{\n\"biome\": \"minecraft:plains\",\n\"parameters\": {\n\"temperature\": -0.45, -0.15],\n\"humidity\": [-1, -0.35],\n\"continentalness\": [-0.11, 0.3],\n\"erosion\": [-0.7799, -0.375],\n\"weirdness\": [-1, -0.9333],\n\"depth\": 0,\n\"offset\": 0\n}\n}\n\nMore biomes can be added by including more entries in the “biomes” list. It can\nand often may include repeats. Each entry must also contain all of the\nparameters listed above. Unless otherwise specified, all of these parameters can\neither be a single constant, or a list of two constants, which serves as a min\nand max range of values. These must be in order from min to max; failure to do\nso will cause the data pack to not validate.\n\ntemperature, humidity\n\nThese are named completely arbitrarily, and have no bearing on the actual\ntemperature or humidity of the biome that impacts gameplay in any way. You can\nmake both a “desert” and “snowy” biome have a temperature of 0, and all it will\nmean is that they will be placed near each other (unless other parameters forbid\nthis). These parameters just refer to different noise maps that are available.\nThese should each be a value between -1.0 and 1.0. The closer a value is to 0,\nthe more frequently that biome will appear, or the larger.\n\ndepth\n\nUsed exclusively for cave biomes, and is otherwise 0. Positive values cause that\nbiome to be placed deeper in the world, and the area above it to be filled with\nother biomes of lower depth values that meet the other parameters of that space.\nIn the vanilla depth density function, a depth of 1.0 corresponds to\napproximately 128 blocks below the surface, but this can vary if you've changed\nthe Final Density or the depth density function in your Noise Router.\n\noffset\n\nHelps to limit the relative size of the biome. Accepts a value between 0 and\n1.0, and must be a single constant, not a list. Larger values reduce the size of\nthe biome, and allow biomes of neighboring parameter values to fill the space.\nThis can also result in the biome becoming rarer, if it was already small enough\nthat a positive offset causes some of its placements to disappear.\n\nweirdness\n\nThis parameter corresponds to the ridges density function, which is responsible\nfor rivers and mountain peaks. Values closer to 0 tend to correspond to rivers,\nand values further from 0 tend to correspond to peaks, before dipping back to\nmore level terrain. The vanilla overworld also uses this parameter to place\n\"variant\" biomes like Bamboo Jungles or Pale Gardens, which otherwise might\nshare similar parameters to their base biomes (Jungles and Dark Forests)\n\ncontinentalness, erosion\n\nThese are the two parameters that influence a biome’s placement on the density\nfunctions of the same names used for Terrain. In the vanilla Overworld, only\nthese values will affect biome position relative to the shape of the terrain.\nFor the vanilla Overworld:\n\nHigh continentalness corresponds to inlands terrain.\nLow continentalness corresponds to ocean terrain.\nHigh erosion corresponds to flat terrain.\nLow erosion corresponds to jagged terrain.\n\nThe above rules may not necessarily hold true if you have a Final Density that\ndiffers from the vanilla Overworld.\n\nThe best way to view and manipulate the biome source and how it may look in the\nworld is with [Misode’s generator.\nHowever, it may not show completely accurate biome placement if you are taking\nadvantage of continentalness and/or erosion.\n\nBiomes\n\nFolders: biome\nOptional Folders: configured_carver, placed_feature,\nconfigured_feature\n\nThis is where the most configurability and excitement, and least limitations,\ncomes into play. Biomes are really just designated areas that can have the\nfollowing things defined:\n\nPrecipitation (True/False)\nTemperature\nUsed to determine rain or snow if Precipitation is true\nAlso influences natural grass and foliage coloration, along with Downfall\nOverride colors for grass, foliage, sky, fog, water, and water fog\nFor grass and foliage, this color is added to the color determined by\nTemperature and Downfall, which references the respective colormaps in the\nResource Pack.\nParticles, if any (such as in many Nether biomes)\nMusic and ambient sounds\nCave and canyon (ravine) types\nNaturally spawning mobs\nFeatures\n\nNot all of these need to be defined, but they all need to be present, even if\nempty. As always, it’s best to use\nMisode’s generator to ensure all\nrequired fields are accounted for. It also has useful tools for selecting\ncolors, where appropriate.\n\n\n\nIf you are modifying a vanilla biome (or a biome from another mod or data pack),\nyour biome will necessarily be incompatible with any other data packs that\nmodify that biome, too. This means you can’t, for example, add more Diamonds to\nthe vanilla Swamp biome, and then also include Terralith -- you would need to\ninstead use Terralith’s Swamp biome as a base and add more diamonds to that, if\nyou want to use both in the same world.\n\n\n\nNaturally Spawning Mobs\n\nCalled “Spawners” (not confusing at all), this is what decides what mobs will\nspawn in this biome, at what rarities and in what quantities.\n\n\n\nThis does not dictate those mobs’ spawning conditions–for the most part, we\ncan’t change that. Passive Mobs will always need Grass Blocks and light to\nspawn, and Hostile Mobs will still need a low enough light level as defined in\nthe Dimension Type. Some mobs, like Sniffers and Camels, don’t have as strict\nspawning conditions because they don’t spawn naturally in vanilla. This means\nthey can spawn anywhere in the biome, even if it doesn’t make sense.\n\n\n\n{\n\"spawners\": {\n\"ambient\": \n{\n\"type\": \"minecraft:bat\",\n\"maxCount\": 8,\n\"minCount\": 8,\n\"weight\": 10\n}\n],\n\"axolotls\": [],\n\"creature\": [\n{\n\"type\": \"minecraft:sheep\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 12\n},\n{\n\"type\": \"minecraft:pig\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 10\n},\n{\n\"type\": \"minecraft:chicken\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 10\n},\n{\n\"type\": \"minecraft:cow\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 8\n},\n{\n\"type\": \"minecraft:horse\",\n\"maxCount\": 6,\n\"minCount\": 2,\n\"weight\": 5\n},\n{\n\"type\": \"minecraft:donkey\",\n\"maxCount\": 3,\n\"minCount\": 1,\n\"weight\": 1\n}\n],\n\"misc\": [],\n\"monster\": [\n{\n\"type\": \"minecraft:spider\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 100\n},\n{\n\"type\": \"minecraft:zombie\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 95\n}\n]\n}\n}\n\nSpawners are defined by first opening up a list of one of several categories,\nsuch as Monster, Creature, Water Ambient, or Axolotl. You can make mobs spawn in\nwhatever category you want, but if you put it in the wrong category than it\nbelongs (generally, Creature for passive mobs, Monster for hostile mobs, etc.),\nthey may either fail to spawn entirely, or overspawn and exceed the mobcap. For\nthis reason, it is advised that you only spawn mobs in their correct category;\nif you don’t know which it belongs to, refer to a vanilla biome that spawns that\nmob and see where it’s placed.\n\nAn individual mob spawner entry includes the mob type, its weight (which works\njust like loot tables) and a min and max count. These latter values determine\nhow many mobs will spawn within a group as one successful spawn attempt of that\nmob type. The min must be greater than 0.\n\nSpawn Costs\n\nSpawn Costs are an optional field within the biome file, and are used to limit\nthe frequency of spawns around mobs of a certain type, within that biome only.\nIn vanilla, this is used to limit the number of Endermen that appear in Warped\nForests, and Skeletons that appear in Soul Sand Valleys.\n\n{\n\"spawn_costs\": {\n\"minecraft:enderman\": {\n\"charge\": 1.0,\n\"energy_budget\": 0.12\n}\n}\n}\n\nA Spawn Cost for an individual mob consists of an energy_budget, and a charge,\nwhich are both float values. These are a little hard to explain, but\nessentially, the “charge” is used to calculate an individual mob’s contribution\nto the overall “energy budget” shared by all mobs of that type in the biome. If\nthe value calculated from that charge would exceed that energy budget, it fails\nto spawn. This is very simplified, and indeed somewhat unintuitive, as the\ncharge will generally be higher than the energy budget.\n\nIf you’d like to learn more about how this works, see the wiki entry relating to\nit [here.\n\nCarvers\n\nThis is where the legacy caves and ravines are defined for the biome. They are\nsplit into two steps: air and liquid, which behave as you would expect; either\nproducing regular air caves, or flooded caves.\n\nYou can define custom caves or canyons with a configured_carver, including\ndefining what types of blocks the cave will be allowed to replace (which is why\nit’s called a carver), their frequency, size, and other values. To explore this\nfully, it’s recommended to mess with the various fields using\nMisode’s generator.\n\nFeatures\n\nFeatures are the real meat of a biome. These are everything that actually fills\nup the biome and gives it character beyond the terrain and surface. Trees,\nflowers, ores, geodes, granite deposits, and sometimes small structures like\nDesert Wells are all features. There is a lot you can do here, but the options\naren’t limitless.\n\nFor one, there’s the issue of performance. Larger and more common features make\nloading new chunks slower, as do features that have hyper-specific location\nrequirements to spawn.\n\nFor two, some specific shapes are harder to achieve, and some common features\naren’t as configurable as others. Trees are some of the most configurable\nfeatures in the game, able to use any block or combination of blocks for their\ntrunks, leaves, roots, and more, and can be used to make elaborate shapes and\nfeatures that don’t even look like trees. Conversely, the coral reefs in Warm\nOceans are easy to replicate and adjust the frequency and location of, but their\nshapes and the blocks they’re made of cannot be changed at all.\n\nAs such, it’s often better to have some broad strokes for the “feel” or\natmosphere you want for a biome in mind, rather than planning everything down to\nthe shape, as flexibility may be necessary.\n\n{\n\"features\": \n[],\n[\"minecraft:lake_lava_underground\", \"minecraft:lake_lava_surface\"],\n[\"minecraft:amethyst_geode\"],\n[\"minecraft:monster_room\", \"minecraft:monster_room_deep\"],\n[],\n[],\n[\n\"minecraft:ore_dirt\",\n\"minecraft:ore_gravel\",\n\"minecraft:ore_granite_upper\",\n\"minecraft:ore_granite_lower\",\n\"minecraft:ore_diorite_upper\",\n\"minecraft:ore_diorite_lower\",\n\"minecraft:ore_andesite_upper\",\n\"minecraft:ore_andesite_lower\",\n\"minecraft:ore_tuff\",\n\"minecraft:ore_coal_upper\",\n\"minecraft:ore_coal_lower\",\n\"minecraft:ore_iron_upper\",\n\"minecraft:ore_iron_middle\",\n\"minecraft:ore_iron_small\",\n\"minecraft:ore_gold\",\n\"minecraft:ore_gold_lower\",\n\"minecraft:ore_redstone\",\n\"minecraft:ore_redstone_lower\",\n\"minecraft:ore_diamond\",\n\"minecraft:ore_diamond_medium\",\n\"minecraft:ore_diamond_large\",\n\"minecraft:ore_diamond_buried\",\n\"minecraft:ore_lapis\",\n\"minecraft:ore_lapis_buried\",\n\"minecraft:ore_copper\",\n\"minecraft:underwater_magma\",\n\"minecraft:disk_sand\",\n\"minecraft:disk_clay\",\n\"minecraft:disk_gravel\"\n],\n[],\n[\"minecraft:spring_water\", \"minecraft:spring_lava\"],\n[\n\"minecraft:glow_lichen\",\n\"minecraft:patch_tall_grass_2\",\n\"minecraft:patch_bush\",\n\"minecraft:trees_plains\",\n\"minecraft:flower_plains\",\n\"minecraft:patch_grass_plain\",\n\"minecraft:brown_mushroom_normal\",\n\"minecraft:red_mushroom_normal\",\n\"minecraft:patch_pumpkin\",\n\"minecraft:patch_sugar_cane\",\n\"minecraft:patch_firefly_bush_near_water\"\n],\n[\"minecraft:freeze_top_layer\"]\n]\n}\n\nBest practice is to have the “features” section of your biome consist of 11\nlists (defined with square brackets: [ ]), called “steps”, but you can have any\nnumber of steps, fewer or greater. Generally, features will be placed in order\nbased on which step they appear in, from top to bottom. So, if you want to place\nTree features with leaves made of Stone, and then place Ore features that get\nplaced in the stone, you would put those features in separate steps, with the\nOre feature in a later step from the Tree.\n\nOther parts of the game refer to these steps by name, representative of the\norder they generate in, specifically for things like Custom Structure Generation\nto reference which step of generation those should appear in. However, the names\nthemselves are arbitrary and just reflect which steps vanilla chooses to put its\nfeatures in; any feature type can go in any step. For interest’s sake, these\ndesignations are, in order from first step to last:\n\nRAW_GENERATION: Where End biomes place the small circular endstone\nislands\nLAKES: Where Overworld biomes place lava lakes, and used to place water\nlakes\nLOCAL_MODIFICATIONS: Where Overworld Biomes place Amethyst Geodes, and\nthe Frozen Ocean biome places Icebergs\nUNDERGROUND_STRUCTURES: Where Overworld Biomes place Dungeons and Fossils\nSURFACE_STRUCTURES: Where the Desert biome places Desert Wells\nSTRONGHOLDS: No vanilla biomes place features here, but you can and it’ll\nwork fine\nUNDERGROUND_ORES: Where all Overworld biomes place ores (which includes\nactual ore blocks, as well as the blobs of Dirt, Gravel, and Stone variants),\nas well as discs that generate on the floor underwater\nUNDERGROUND_DECORATION: Where all Nether biomes place ores (which\nincludes actual ore blocks, as well as the blobs of Gravel and Blackstone),\nand where Overworld mountain biomes place blobs of Infested Stone\nFLUID_SPRINGS: Where all Overworld and Nether biomes place water and/or\nlava springs (individual fluid blocks that may or may not spill out of walls\nor ceilings)\nVEGETAL_DECORATION: Where all biomes place features such as trees,\nflowers, cacti, Huge Fungi, Chorus Plants and similar features\nTOP_LAYER_MODIFICATION: Where all Overworld biomes place a feature that\ncauses snow or ice to cover the top blocks if the temperature is\nsufficiently low at that altitude\n\nNote that there are some exceptions to generation order. For example, Deltas\nwill generally spawn after everything else regardless of which step they’re\nplaced in. Conversely, Lakes often spawn before other features, even if they are\nin a later step.\n\n\n\nIf you have two or more features that appear in one step together (regardless of\nwhich step it is) in multiple biomes, they must always be in the same order, or\nthe game will throw an error and fail to load (this is called a feature order\ncycle error). For the same reason, you can't repeat a feature in the same step,\neven one after the other, if that feature is used in a different biome.\n\n\n\nFeatures are themselves composed of two other file types: placed_features, and\nconfigured_features. A configured_feature defines what type of feature it is,\nphysically, such as an ore or a tree. The placed_feature determines under what\nconditions it spawns, such as in or on what blocks, at what Y level, or other\nfactors. The placed_feature is what the biome file references.\n\nTechnically, the configured_feature can be defined in-line in the\nplaced_feature, however it’s good practice to separate these files. This allows\neasier delineation when creating and editing -- as some configured_feature types\ninclude in-line placements like a placed_feature -- and also makes it easier to\nreuse a configured_feature in multiple placed_features.\n\nConfigured Features\n\nThere are many configured_feature types, each with different required fields.\nListing each in detail would be unhelpful, outside the scope of this guide, and\na duplication of efforts --\n[the wiki serves as a great\nreference to become familiar with the available feature types. As always,\nutilizing Misode to keep track of\nrequired fields is highly recommended. Furthermore, if you do have an idea of a\nvanilla feature that looks similar to what you want to create, referencing it or\nstarting from it as a base, and then modifying it, is a completely valid\nstrategy.\n\nInstead, what this section of the guide will go over is point out which features\nare best for what purpose, and which features are surprisingly difficult to work\nwith, primarily as this knowledge may help keep you from becoming frustrated\nthat you can’t figure out how to do something that is, in fact, not possible.\n\n{\n\"type\": \"minecraft:tree\",\n\"config\": {\n\"decorators\": ],\n\"dirt_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:dirt\"\n}\n},\n\"foliage_placer\": {\n\"type\": \"minecraft:blob_foliage_placer\",\n\"height\": 3,\n\"offset\": 0,\n\"radius\": 2\n},\n\"foliage_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:oak_leaves\",\n\"Properties\": {\n\"distance\": \"7\",\n\"persistent\": \"false\",\n\"waterlogged\": \"false\"\n}\n}\n},\n\"force_dirt\": false,\n\"ignore_vines\": true,\n\"minimum_size\": {\n\"type\": \"minecraft:two_layers_feature_size\",\n\"limit\": 1,\n\"lower_size\": 0,\n\"upper_size\": 1\n},\n\"trunk_placer\": {\n\"type\": \"minecraft:straight_trunk_placer\",\n\"base_height\": 4,\n\"height_rand_a\": 2,\n\"height_rand_b\": 0\n},\n\"trunk_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:oak_log\",\n\"Properties\": {\n\"axis\": \"y\"\n}\n}\n}\n}\n}\n\nAs mentioned above, some configured_features, like trees, offer a lot of control\nand flexibility. Trees have several different shapes to choose from for their\ntrunks and leaves, as well as optional roots (such as what Mangroves have),\noptions for decorations on any face of leaves, and can accept one or multiple\ndifferent blocks to make up each of these facets.\n\nThe Ore feature type does not have quite as many fields, but still presents a\ngood deal of configurability. Making a new ore configured_feature entails\ndetermining what the block being placed is (the state) and what blocks it tries\nto get placed in (the target), which can be a block tag. As you can see in the\nbelow example for Coal, you can also list multiple state and target pairs in one\nfeature, which vanilla uses to place the appropriate Deepslate variant if the\nblock it gets placed in is a Deepslate or Tuff Block rather than Stone or a\nstone variant.\n\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"discard_chance_on_air_exposure\": 0.0,\n\"size\": 17,\n\"targets\": [\n{\n\"state\": {\n\"Name\": \"minecraft:coal_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:stone_ore_replaceables\"\n}\n},\n{\n\"state\": {\n\"Name\": \"minecraft:deepslate_coal_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:deepslate_ore_replaceables\"\n}\n}\n]\n}\n}\n\nThe size is self-explanatory but is not indicative of the actual quantity of the\nstate blocks that will be placed. More info on that relationship can be found on\nthe [wiki.\nDiscard_chance_on_air_exposure is a chance between 0.0 and 1.0 to intentionally\nfail to spawn the feature if it touches air, such as in a cave. This is used in\nvanilla for so-called “buried” ore features like Iron and Diamonds, to encourage\nother forms of mining than just caving.\n\nThe Ore feature type is also what is used for the blobs of dirt, gravel,\ngranite, tuff, and other blocks in the Overworld.\n\nMoving into feature types that are not configurable and what you can do about\nit. End Islands, Basalt Pillars, Ice Spikes, Glowstone Blobs, and Coral Claws\nare all examples of features that have no configuration at all, meaning their\nshape and block palette is hardcoded. You can still change how they get placed\nwith a placed_feature later, but you can’t change what these features physically\nare.\n\nFor cases like these where you may want to make use of those specific shapes,\nbut can’t recreate them with other features (End Islands are a good example),\nyou can create features to replace those blocks with other blocks in a later\nstep. A good feature to use for this is geodes, because they can define a list\nof blocks that they are not able to replace, which can include all blocks except\nthe desired replaceables.\n\nThis just allows you to replace a target block with a state block in a\n3D-diamond with a defined radius. It unfortunately doesn’t support block tags.\nIt also has a maximum radius of 12, so you may need a higher quantity of them\nusing your placed_feauture later to get consistent coverage.\n\nPlaced Features\n\nA placed_feature typically references a configured_feature, and determines how\nit gets placed in the world. For some features, like Trees, they will obey\nwherever your placements happen to define as valid. For other features, like Ice\nSpikes, they need to adhere to hardcoded conditions of the feature type, which\nare not always obvious. Ice Spikes for example can only spawn on Snow Blocks,\nregardless of what the placed_feature says.\n\nAs with the previous section, this guide will not go over every type of\nplacement that can be included, nor every field they contain. These are all\ncovered in detail on the wiki, and\ngenerating them can be aided using\nMisode.\n\nHowever, there are a handful of placement types that are used extremely\ncommonly, and so we will go over what those are, how to use them, and when they\nmay not be needed.\n\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"discard_chance_on_air_exposure\": 0.0,\n\"size\": 10,\n\"targets\": [\n{\n\"state\": {\n\"Name\": \"minecraft:copper_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:stone_ore_replaceables\"\n}\n},\n{\n\"state\": {\n\"Name\": \"minecraft:deepslate_copper_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:deepslate_ore_replaceables\"\n}\n}\n]\n}\n}\n\nGenerally, placements are calculated in order from first to last. For some\nplacement types, this is irrelevant, while for others, being listed before or\nafter another placement can dramatically alter the spawning behavior. The\nfollowing placement types are the most commonly used; a majority of\nplaced_features will use some combination of these placements:\n\ncount\n\nThe number of spawn attempts this feature will make per chunk. Accepts a\nconstant, or other number providers like uniform or trapezoid. If excluded, the\nplaced_feature will make only 1 spawn attempt per chunk.\n\ncount_on_every_layer\n\nAn alternative to count. A little hard to explain, but essentially includes some\nrandom X and Z distribution, and Y distribution based on layers of air or fluid.\n\nrarity_filter\n\nAccepts a positive integer. Essentially divides any previous count-type\nplacements by this value. For example, a rarity of 1 will cause no change, a\nrarity of 2 will make the feature half as common, a rarity of 5 will make it 5\ntimes less common, etc. If no count-type placement was specified before this\nplacement, the count is assumed to be 1.\n\nin_square\n\nThis is used to include some random distribution within the chunk. Without this\nplacement, all of the spawn attempts would be made at the chunk’s 0x, 0z\ncoordinate. If you are using count_on_every_layer, you do not need to use\nin_square.\n\nheight_range\n\nDetermines the height this feature will try to spawn in. Accepts a constant, or\nother number providers like uniform or trapezoid. Whether using a constant or a\nnumber provider, each value must also be defined as “absolute” (this exact Y\nlevel), “above_bottom” (this many blocks above the lowest Y level of this\ndimension) or “below_top” (this many blocks below the highest Y level of this\ndimension, always a positive number). This allows some flexibility for\nsituations such as if the height of the dimension may change or is unknown.\n\nheightmap\n\nAccepts one of a few different heightmaps, including MOTION_BLOCKING,\nOCEAN_FLOOR, and WORLD_SURFACE_WG. This causes the feature to attempt to spawn\nat the highest block in the chosen X and Z coordinate, according to the selected\nheightmap. Unsurprisingly, this can cause undesired behavior if the dimension\nhas a roof, like the Nether.\n\nbiome\n\nDoesn’t have any other fields. Ensures that this feature won’t be allowed to\nspawn if the spawn attempt would be inside a biome that does not contain this\nplaced_feature in its listed features. Without it, if a chunk contains two\nbiomes, the feature would be allowed to “bleed” into the neighboring biome, even\nif it doesn’t belong there, as long as all other conditions are met (for\nexample, a Desert’s Cactus feature spawning in an adjacent Beach biome).\n\nblock_predicate_filter\n\nCan be used to apply one or more conditions based on nearby blocks, including\nthe block that has been selected for the spawn attempt. This can include details\nlike if the block below is solid or in a block tag, whether it has a sturdy\nface, or is a valid location for a sapling or mushroom to be placed.\n\nOne of the most important things to keep in mind when creating placed_features\nin particular is performance. More than anything else in worldgen, the\nplaced_features are going to have the greatest impact on the speed of your chunk\ngeneration. Features that have a high count, or hyper-specific\nblock_predicate_filters, can cause chunks to load more slowly. Similarly,\nincluding a height range for a feature that includes a lot of space that the\nfeature can’t spawn in can impact this chunk generation, as all of those failed\nspawn attempts still have to be calculated.","description":"This guide goes over how to create every step of a custom dimension, which includes custom biomes, terrain, and features.","url":"/wiki/worldgen/custom-worldgen/","tags":[]},{"title":"Page Formatting","content":"Page Formatting\n\nLast Updated: 1-31-2025\n\nThis section goes over how we format wiki pages. We like to be consistent, so\nplease read through this section carefully and use these features to your\nadvantage:\n\nBasic Writing Guidelines\n\nWhen writing for the wiki, write in a way that is easy to understand and easy\nfor beginners to understand. Put yourself in the viewer's shoes. _What\nconfused you when you first learned about the topic? What new terms did you\nlearn?_ Avoid using technical terms without explaining them or point to a\nresource that explains them.\n\nDocumentation and tutorials are a great way to learn, but sometimes you don't\nneed to read every part of a page to understand it. When writing for the wiki,\nwrite in a way that makes it easy to scan and understand quickly. Some\nrecommendations are using white space to your advantage to break your page into\neasily digestible chunks.\n\nWhen learning a concept, it is helpful to have concrete examples that people can\nrefer to instead of just using a concept. This will help wiki-goers understand\nthe concept better and make it easier to remember.\n\nWriting Style\n\nThe datapacking community is a diverse group of people with different\nbackgrounds; many people don't speak English as their first language!\n\nWhen writing, try to follow these guidelines:\n\nUse the active voice. For example, instead of\nThe pig is teleported by the command, write\nThe command teleported the pig.\nDon't use unnecessary adverbs or adjectives\nTry not to use the words: _obvious, simple, basic, easy, actual, just,\nclear,_ and however\nExplicitly reference what you are explaining\nUse 's for indicating possession\nUse the Oxford comma\n\nTechnical information\n\nAll content on the website (except a few small exceptions) are made using a\ntechnology called mdsvex. This technology enables people like you to insert\nMarkdown with svelte components.\n\nIt is recommended to know what the proper way to format Markdown is in order to\nstay consistent and prevent confusion.\n\nThe front matter title is the same as the title in the sidebar and the title\non the page (heading 1 or single #)\nUse bold and italics sparingly and only when emphasis is needed\nUse headings to break up the page into sections\nCode blocks are used to show code snippets or commands\nAdmonitions are used to show important information\nunrelated to the content of the page\nTables are used to show large amounts of data\n\nEach page is made of 3 parts:\n\nfront matter (metadata about the page such as title, description, tags,\nversion, etc.)\ncontent (the actual content of the page)\ncomponents (custom components that allow for interactivity or other features\nnot able to be reproduced with markdown)\n\nEach is crucial to making the page look and feel how it does.\n\nFrontmatter\n\nWe try to keep the front matter as minimal as possible, but it is still\nrequired. Without it, the page will not display correctly on search engines or\nother sites. The front matter for this page looks like this:\n\ntitle: \"Site Development\" description: \"This page is meant to be an introduction\nto formatting a page for the wiki. In it is multiple examples which you can\nexamine raw in the site source code.\"\nversion: 1.21.5\n\nFront matter is denoted with triple hyphens (---) at the top of the page and\nthe end of the front matter.\n\nThe title should be the same as the title in the sidebar in order to reduce\nconfusion.\nThe description should be a short summary of the content of the page in\norder to show people what all is covered in the article.\nThe version should be set to the latest version that the page has been and\nworks in. If the page works in 1.21.4 but not in 1.21.5 or later, this should\nbe set to 1.21.4.\n\nCustom Elements\n\nOur markdown system adds unlimited customizability to the way we format our\npages. As of the time of writing, we have the following features:\n\nAdmonitions\nCode Titles\nMCFunction Formatting (Thanks Snave!)\nHighlighting\n\nAdmonitions are a way to warnings, info or tips, or other important information\nto your page.\n\n\n\nThis is an example of an info box.\n\n\n\n\n\nThis is an example of an info box.\n\n\n\nCode blocks are a way to format code in your page. These code blocks come with\nthe option to add a title to the code block for clarity. The Modpack Dev Wiki\nsupports syntax highlighting for MCFunction which are used for code samples\nwhenever possible.\n\nfunction example() {\nconsole.log(\"Hello World!\");\n}\n\nHighlighting is a way to highlight specific text. It isn't commonly used, but\nexists.\n\nHighlighted Text like this.\n\nStandardized Elements\n\nThe wiki uses a few elements that are standardized across the entire wiki. Right\nnow this only consists of command syntax. You can find the command syntax we use\nin the commands page.","description":"This page is an introduction to formatting page content, and details about how the wiki handles formatting.","url":"/contribute/formatting/","tags":[]},{"title":"Git Practices","content":"Git Practices\n\nLast Updated: 12-13-2024\n\nThis page is an introduction to how we use Git in the\nwiki repository. In order to keep the\nwiki consistent and reputable, we have a few rules that we follow.\n\nGit provides a lot of features that are great for collaboration, and we try to\nuse them as much as possible.\n\n\n\nThis guide assumes you already have experience using Git before.\n\n\n\nForking and PRs\n\nForks are a great way to work on the wiki without introducing unfinished pages,\nchanges, etc. to main. You can click the\n\"Fork\" button in the top right\ncorner of the repository to create a fork of the repository. This will create a\ncomplete copy of the repository that you can work on.\n\nOnce you have forked the repository, you can clone it to your local machine.\n\nWhen it comes time to merge your changes, you can create a pull request, and a\nwiki contributor will review your contribution.\n\nBranches\n\nBranches are useful additions to help separate features in your fork. We use\nkebab-case for branch names meaning the branch name should be all lowercase\nwith hyphens to separate words. For example, if you are working on a page called\n\"Adding New Features\", the branch name should be adding-new-features.\n\nWe do not recommend you use branches for the main repository, even if you have\npermissions to. Branches in the repository are mainly for upcoming Minecraft\nversions or huge upcoming reworks, if you believe you have a reason to add a\nbranch to the main repository, let a wiki admin know.\n\nCommit Messages\n\nCommit messages are a great way to keep track of what changes have been made to\nthe wiki. Summarize the changes in the commit message and use the imperative\nmood.\n\nFor example, if you are adding a new page called \"Adding New Features\", the\ncommit message should be Add new page for adding new features. If you are\nfixing a typo on a page, the commit message could be\nFix typo in page about adding new features.\n\nOptionally, you can add a short description of the changes in the commit\nmessage. This is not required, but it is recommended.\n\nMerging\n\nWhenever you start working on a new branch or features, pull the latest changes\nfrom the main branch. This will ensure that you have the most up-to-date\nchanges.\n\nYou will likely run into an issue with the search.json file, which is used to\ngenerate the search index. This file is generated automatically and should not\nbe manually edited. A solution to this is to remove the search.json file and\noptionally run the search index generation script. This will regenerate the file\nand you can commit it.\n\nnode run ./gen_search_indexes_node.js\n\nOR\n\nbun ./gen_search_indexes.js\n\nOther Important Information\n\nMake a description of your changes in your PR.\nReviewers: Proofread changes before approving them.\nReviewers: It's not required, but it's recommended the changes follow American\nEnglish for consistency sake.","description":"This page is an introduction to our Git practices a page for the wiki.","url":"/contribute/git-practices/","tags":[]}]