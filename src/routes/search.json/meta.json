[{"title":"Home","content":"Welcome to the Modpack Dev Wiki!\n\nWelcome to the Modpack Dev Wiki, a resource for everything related to Minecraft\nDatapacks. This community-built wiki has got guides, tutorials, and\ndocumentation to help you create and modify Minecraft Datapacks.\n\nNew to Minecraft Datapacks?\n\nDon't worry! You're in the right place. We've got a guide on\nhow to make a datapack for those of you with no or\nlittle experience. If you get stuck, don't hesitate to ask in our Discord\nServer. Pages on this wiki have been written with beginners in mind - you should\nhave no trouble working through these resources.\n\nWhat are Minecraft Datapacks?\n\nMinecraft Datapacks are like addons - they are a Minecraft feature that lets you\ncustomize Minecraft worlds without mods. They allow you to modify and enhance\nthe game by adding new features and mechanics by using Minecraft commands,\nadvancements, worldgen, and more!\n\nWith datapacks, you can:\n\nAdd and modify custom recipes\nModify existing or create new loot tables\nAdd new advancements and enchantments\nCreate unique structures\nAnd much more!\n\nContribute\n\nThis project wouldn't be possible without the support of community members. We\nencourage you to contribute to this wiki if you want to write any pages, correct\nany mistakes, or share any of your knowledge!\n\nYou can hit the Edit button on any page to open the GitHub page for the\ncurrent wiki page. All our contributions are done via GitHub and are written in\nMarkdown. For more information, find the Contribution section of this page, or\nread our contribution guide on our\nGitHub repo.","description":"Welcome to the Modpack Dev Wiki, a resource for everything related to Minecraft Datapacks. We've got guides, tutorials, and documentation to help you build your knowledge about data packs.","url":"/","tags":[]},{"title":"Credits","content":"Credits\n\nThe Modpack Dev Wiki is a fork of the Datapack Wiki, managed by Datapack Hub, based\non an original design and idea by Aandeel.\n\nMade by Chemma, Emmcha, Chemkma, and Echmakyl!!","description":"The Modpack Dev Wiki is brought to you by [Datapack Hub](https://datapackhub.net) in collaboration with Aandeel.","url":"/credits/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/guide/intro-resourcepack/","tags":["intro"]},{"title":"Removing items from the game","content":"Removing items from the game\n\nAdding content to your modpack is great, but sometimes mods can either add things that just don't fit into your vision for the pack, or maybe just have overlap with another mod you have installed. This article will go into some methods of streamlining your pack and removing content from your pack. Some mods that're useful for removing items from your game are Reliable Remover,KubeJS, and Registry Blocker.\n\nReliable Remover\n\nReliable Remover is a simple json-based tool that can remove the functionality and obtainment methods for various items. More details of the mods functionality, as well as examples of usages can be found on its wiki.\n\n\n\nRunning the in-game commands /reliable_remover hand, /reliable_remover hotbar, and /reliable_remover inventory are quick ways to get the IDs to put into the array.\n\n\n\nKubeJS\n\nThis KubeJS script removes everything in the global.nukelist array from all tags, recipes, and recipe viewers.\n\n\n\nThe following script only works for 1.20.1\n\n\n\nglobal.nukelist = \n'modid:item',\n'modid:fluid',\n'@modid',\n]\n\nServerEvents.tags('item', event => {\nevent.removeAllTagsFrom(global.nukelist)\nevent.add('modpack:nukelist', global.nukelist)\nevent.add('c:hidden_from_recipe_viewers', global.nukelist)\n})\n\nServerEvents.tags('fluid', event => {\nevent.removeAllTagsFrom(global.nukelist)\nevent.add('modpack:nukelist', global.nukelist)\nevent.add('c:hidden_from_recipe_viewers', global.nukelist)\n})\n\nServerEvents.recipes(event => {\nevent.remove({ input: global.nukelist })\nevent.remove({ output: global.nukelist })\n})\n\nThe following can be put in client scripts to add a tooltip notifying the user that an item has been removed, and to report the issue to the modpack developers in cases of the nukelist not being thorough.\n\nItemEvents.tooltip(event => {\nevent.add([global.nukelist], Text.red('This item has been removed, report to the modpack developers how you obtained this item!'))\n})\n\nIf [LootJS is installed, the following can be added to the nuking.js server script previously mentioned to remove it from loot tables, entity drops, and other methods of obtaining items.\n\nLootJS.modifiers(event => {\nevent\n.addLootTypeModifier(\nLootType.ENTITY,\nLootType.UNKNOWN,\nLootType.BLOCK,\nLootType.CHEST,\nLootType.FISHING,\nLootType.GIFT,\nLootType.ADVANCEMENT_ENTITY,\nLootType.ADVANCEMENT_REWARD,\nLootType.PIGLIN_BARTER,\n)\n.removeLoot(global.nukelist);\n})\n\n\n\nRunning the in-game commands /kubejs hand, /kubejs hotbar, and /kubejs inventory are quick ways to get the IDs to put into the array.\n\n\n\n\n\nNote that neither Reliable Remover nor KubeJS fully removes an item from being registered in-game, and only attempts to remove methods of obtaining said item.\n\n\n\nRegistry Blocker\n\nRegistry Blocker is a mod that blocks registries. It is as invasive and destructive as it sounds. Instructions on how to use it is documented on the mod page.\n\n\n\nMessing with the game registry with mods such as Registry Blocker is unsafe, and may lead to issues such as data validation errors, log spam, and even crashes. It should only be considered as a last resort if neither a mods config, KubeJS, Reliable Remover, or datapacks work to remove an item.\n\n","description":null,"url":"/guide/removing-content/removing-items/","tags":["todo"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/guide/removing-content/removing-blocks/","tags":[]},{"title":"Modifying attributes of items and entities","content":"Adding attributes to items/gear\n\nBoth Attribute Setter and KubeJS can add attributes to items, armor, and curios. This will cover how to do both. \n\nAttribute Setter\n\n\n\n\n\nUUIDs for the uuid field can be obtained through UUID generator sites such as https://www.uuidgenerator.net\n\n\n\nKubeJS\n\nWIP\n\n\n\nOther mods that have this functionality are Attributizer and Custom Item Attributes, but they were not included in this guide for brevity and redundancy.\n\n","description":null,"url":"/guide/attribute-modification/","tags":[]},{"title":"MissingNo.","content":"Intro to Datapacks\n\nA datapack is a collection of data stored in a folder or .zip file used to modify elements of the game. Due to them being predominately JSON-based, they are relatively easy to get into with no prior experience. Both Vanilla Minecraft and most mods use data in their implementation, meaning that they can be modified via datapacks. Common applications of data in vanilla/mods are recipes, tags, advancements, and worldgen, meaning that these elements of the game can be added, removed, and modified with datapacks. \n\nMaking a datapack\n\n1. Create a folder\nThis can be done by right-clicking your desktop or inside another directory, and pressing \"New\" -> \"Folder\". You can also press CTRL + Shift + N as a shortcut. You can name this folder anything.\n\n2. Open the folder and create the data folder and pack.mcmeta file\nAfter you've opened the folder you just created, create another folder inside of it named data. Then, create a file named pack.mcmeta by right clicking, pressing \"New\" -> \"Text Document\", then renaming the entire thing to pack.mcmeta, including the file extension. Your screen should look similar to the image below.\n\n![Pasted image 20260208190634.png]]\n\n\n\nEnabling file extensions is a must-have when doing nearly anything modpack related. On Windows, they can be turned on by going to Settings -> System -> Advanced -> File Explorer, then clicking the \"Show File Extensions\" tick.\n\n![[Pasted image 20260208164841.png]]\n\n\n\n3. Put information into the pack.mcmeta file\npack.mcmeta files include information on what Minecraft version a datapack is compatible for, among other things. To supply the correct information on what to include in a datapack, use Misode's [pack.mcmeta generator site to create the contents of the file. The only thing that matters here is the pack_format field, which should be 15 if the datapack is made for Minecraft version 1.20.1, and 48 if made for Minecraft version 1.21.1. Other pack formats for different versions can be found here.\n\n{\n\"pack\": {\n\"pack_format\": 15,\n\"description\": \"pack.mcmeta file for 1.20.1\"\n}\n}\n\n{\n\"pack\": {\n\"pack_format\": 48,\n\"description\": \"pack.mcmeta file for 1.21.1\"\n}\n}\n\n4. Create a \"Namespace\" folder inside data folder\nA Namespace determines \"who\" a set of data belongs to in a datapack. If you're adding custom content with a datapack, and not editing anything from the base game or another mod, you should create your own namespace, ex; my_namespace. But if you're modifying files in vanilla or in other mods, you should use theirs instead, otherwise they wouldn't be overridden correctly, ex; minecraft, oreganized. \n\nFor the purposes of this guide, I will be doing all three. \n\n![Pasted image 20260208193742.png]]\n\n5. Create \"data type\" folders inside of the namespace folders\nThe data type folders determine what \"kind\" of data is to be created/modified. For the purposes of this example, we will be changing recipes. On 1.20.1 and below, the data type is called recipes, while on 1.21.1 and above, it's called recipe. \n\nTo find the correct data type for what you want to override/create, there are a couple options. For vanilla Minecraft, you can use sites like [MCasset or Misode to see the default data for the game. For mods, you can either view their source code (usually provided on their Curseforge / Modrinth sites, though not always) or open the mod .jar file in your modpack /mods directory with a program such as WinRAR or 7-Zip.\n\nOreganized mod page\nOreganized source\n\n![Pasted image 20260208201625.png]]\n\n![[Pasted image 20260208201723.png]]\n\n6. Create the data file\nOnce you've figured out exactly what you want to change by looking at the base data, you can override it by copying the exact filepath presented. \n\nLoading datapacks\n\nTo load datapacks, ordinarily you'd have to manually place the file into your worlds datapacks folder, and it would not persist between worlds. However, in a modded environment, there are mods such as [Open Loader and Paxi that automatically load datapacks placed in their config folder, or in other directories such as the/datapacks directory that many launchers support. Additionally, KubeJS can act as a datapack loader, with/kubejs/data/... loading data files put in it. Data loaded through KubeJS will have higher priority than ones loaded through Open Loader or Paxi.\n\nRelated topics:\n\nNeo/Forge data conditions\nMcmeta filters","description":"placeholder","url":"/guide/intro-datapack/","tags":["intro"]},{"title":"Adding biomes to your modpack","content":"Adding Biomes","description":"Adding custom biomes to the game","url":"/guide/worldgen/modifying-biomes/adding-biomes/","tags":["guide","worldgen","biomes","datapack","tutorial","lithostitched"]},{"title":"Removing biomes from your modpack","content":"Removing Biomes","description":"Removing biomes from the game","url":"/guide/worldgen/modifying-biomes/removing-biomes/","tags":["guide","worldgen","biomes","datapack","tutorial","lithostitched"]},{"title":"Removing features from your modpack","content":"Removing worldgen features\n\nRemoving worldgen features is most easily done through worldgen modifiers, such as those provided through Lithostitched. More information on Lithostitched Worldgen Modifiers can be found on their wiki, and can be created using their generator site.\n\nExample worldgen modifier\nRemoves Coal Ore generation from the Overworld.\n{\n\"type\": \"lithostitched:remove_features\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"features\": \n\"minecraft:ore_coal_lower\",\n\"minecraft:ore_coal_upper\"\n],\n\"step\": \"underground_ores\"\n}\n\n\n\nBiome modifiers are also possible through [Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n","description":"Removing worldgen features to your game with datapacks and Lithostitched","url":"/guide/worldgen/modifying-features/removing-features/","tags":["guide","worldgen","features","datapack","tutorial","lithostitched"]},{"title":"Adding worldgen features to your modpack","content":"Adding worldgen features\n\nFeatures need three things to generate in your world:\nConfigured Feature: Determines the type and parameters of the feature you want to generate.\nPlaced Feature: Determines where a Configured Feature should be attempted to be placed using placement modifiers.\nWorldgen modifier: Determines what biomes the Placed Feature can generate in. Implemented through Lithostitched.\n\nConfigured features consist of a type and a config field, where type is the kind of feature generated, and config is any customization for the feature. Available config values depend on what the feature type is. For vanilla feature types, you can use Misode's Configured Feature Generator to easily create feature files. For more information on feature types and configs, see the Minecraft Configured Feature Wiki.\n\nExample Configured Feature:\nDefines a feature that replaces minecraft:stone with an ore feature using minecraft:amethyst, with a size of 8\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"targets\": \n{\n\"target\": {\n\"predicate_type\": \"minecraft:block_match\",\n\"block\": \"minecraft:stone\"\n},\n\"state\": {\n\"Name\": \"minecraft:amethyst_block\"\n}\n}\n],\n\"size\": 8,\n\"discard_chance_on_air_exposure\": 0\n}\n}\n\nPlaced features consist of feature and placement parameters. The feature parameter references a Configured Feature ID, while the placement parameters define where in a biome the feature can spawn. Again, you can use Misode's [Placed Feature Generator to assist in making feature files, and see the Minecraft Placed Feature Wiki for more information on placement parameters.\n\nExample Placed Feature:\nPlaces the amethyst_ore:amethyst_configured feature between y=-20 and y=60, with a count multiplier of 32\n{\n\"feature\": \"amethyst_ore:amethyst_configured\",\n\"placement\": \n{\n\"type\": \"minecraft:count\",\n\"count\": 32\n},\n{\n\"type\": \"minecraft:in_square\"\n},\n{\n\"type\": \"minecraft:height_range\",\n\"height\": {\n\"type\": \"minecraft:uniform\",\n\"min_inclusive\": {\n\"absolute\": -20\n},\n\"max_inclusive\": {\n\"absolute\": 60\n}\n}\n},\n{\n\"type\": \"minecraft:biome\"\n}\n]\n}\n\nLithostitched Worldgen Modifiersconsist of type, biomes, features, and step parameters. type defines what action the modifier will do, biomes consist of a string or array of biome or biome tag IDs, features consist of a string or array of feature or feature tag IDs, and the step parameter defines what phase of worldgen the feature will generate in. More details on worldgen modifiers from [Lithostitched can be found on their wiki. Additionally, Lithostitched has a generator site similar to Misode to aid in production of files.\n\nExample Biome Modifier using Lithostitched:\nAdds the amethyst_ore:amethyst_placed placed feature into all biomes with the #minecraft:is_overworld tag\n{\n\"type\": \"lithostitched:add_features\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"features\": \"amethyst_ore:amethyst_placed\",\n\"step\": \"underground_ores\"\n}\n\n\n\nBiome and Biome Tag IDs can be found by going through /locate biome in-game, and using the arrow keys to navigate\nCommonly used biome tags can be found here\nIf KubeJS is installed, you have a variety of options of dumping registries into your latest.log. Run /kubejs dump_registry minecraft:worldgen/... in-game to see the available options.\n\n\n\n\n\nBiome modifiers are also possible through Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n","description":"Adding worldgen features to your game with datapacks and Lithostitched","url":"/guide/worldgen/modifying-features/adding-features/","tags":["guide","worldgen","features","datapack","tutorial","lithostitched"]},{"title":"Modifying mob spawns","content":"Editing mob spawns\n\nThere are several methods to edit mob spawns, each with varying levels of complexity and control, with the main ones being:\n\nLithostitched - Simplest of the three, allows for basic worldgen modifiers to edit spawns\nIn Control! - Spawn control with extremely verbose JSON\nKubeJS - skript dat shit bay bee!\n\nWith Lithostitched\n\nLithostitched can edit mob spawns a datapack adding a worldgen modifier. You have the option of either adding or removing spawns from biomes. Some examples pulled directly from the Lithostitched wiki are found below.\n\nAdding spawns:\nAdds witch spawns to swamps\n{\n\"type\": \"lithostitched:add_biome_spawns\",\n\"biomes\": \"#c:is_swamp\",\n\"spawners\": {\n\"type\": \"minecraft:witch\",\n\"weight\": 450,\n\"minCount\": 3,\n\"maxCount\": 3\n}\n}\n\nRemoving spawns:\nRemoves zombie spawns from the overworld\n{\n\"type\": \"lithostitched:remove_biome_spawns\",\n\"biomes\": \"#minecraft:is_overworld\",\n\"mobs\": \"minecraft:zombie\"\n}\n\nThese modifiers can be generated through the Lithostitched generator site.\n\n\n\nBiome modifiers are also possible through Neo/Forge biome modifiers, but was not included in this page due to brevity and redundancy. Lithostitched covers most biome modifiers Neo/Forge has, but is more versatile and not loader specific. \n\n\n\nIn Control!\n\nIn Control! uses extremely verbose JSON syntax to edit spawns, and is very useful if you'd like more control over spawns than simply adding mobs to the spawn pool. Additional features over Lithostitched includes, but is not limited to:\n\nGame Stages integration\nAdding gear/NBT to mobs\nY-level control\nDay counter control\nWeather control\n\nWhile it does have a wiki, it is hard to follow at times, and does not include many tangible examples. \n\n\n\nIn Control is not available on Fabric.\n\n\n\n(page needs useful IC examples)\n\nKubeJS\n\nliterally noone knows how tf this works at all bruuu","description":"Guide on modifying mob spawns with various methods","url":"/guide/mob-spawns/","tags":["mobs","lithostitched","guide","incontrol","kubejs"]},{"title":"Introduction to modpack development","content":"Introduction to modpack development\n\nNew to packdev? This article will serve as an introduction to getting started with modpack development, covering introductory topics such as launchers, versions, modloaders, logs, and datapacks. \n\nLaunchers\n\nTo play modded Minecraft, you first need a launcher. Launchers are what allow you to easily add/remove mods from your game, as well as create different instances containing different mods and configurations. Using the Vanilla game launcher to run mods, while sometimes possible, can run into issues, and it a lot less convenient than using any of the options listed below.\n\n| Launcher| Where mods are downloaded from | Additional Notes|\n| ----------------------------------------------------- | ------------------------------ | ------------------------------------------- |\n| Curseforge | Curseforge| Recommended to download without Overwolf |\n| Prism| Curseforge, Modrinth| Has access to both CF and Modrinth|\n| Modrinth| Modrinth| Only has access to Modrinth|\n| ATlauncher| :idk:| :idk:|\n\nWhile launchers have their differences, features, and issues, they are mainly up to personal preference. \n\nVersions and Modloaders\n\nWhile launchers are how you start the game, modloaders are what platform the mods you're using run on. Mods made on Forge generally cannot run on Fabric, and vice-versa. While there are many loaders out there today, only three are relevant for modern modpack development; Forge, Neoforge, and Fabric. \n\n\n| Version | Loaders|\n| ------- | ---------------- |\n| 1.20.1| Forge, Fabric|\n| 1.21.1| NeoForge, Fabric |\n\n\n\nThe performance of a modpack is attributed almost entirely to the content of the mods it has, not the loader. Different modloaders are not inherently more/less performant for running mods than each other.\n\n\n\nLogs","description":"The very basics for modpack development","url":"/guide/intro-intro/","tags":["intro"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/useful-tags/","tags":["todo"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/version-control-tools/","tags":["todo"]},{"title":"Pack Design","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/creative/pack-design/","tags":["todo"]},{"title":"Planning","content":"Planning\n\nDespite modpacks being loose collections of mods, there's a lot of work that goes into \"gluing\" these mods together to make a cohesive experience. This involves planning out progression, removing unused or unwanted contents from mods, and just general game design.\n\nThis page will take you through the planning phase of your modpack, and what you can expect to have to take on when making a modpack.\n\nPrerequisites\nMost of this works involves editing json files, writing KubeJs/Craftweaker scripts, and editing configs.\n\nIt's essential you have have the following (or equivalents) to keep yourself and your pack properly organized:\n\nText editor like VSCodium or Visual Studio Code\nLINK TO VERSION CONTROL PAGE for ensuring work doesn't get deleted\nSome tool to take notes such as Obsidian or any other text editors/paper\n\nSome other things that will improve your experience creating modpacks is technical knowledge of Minecraft, experience playing lots of different kinds of modpacks, and general programming experience. None of these things are required though by any means.\n\nPicking a concept\n\nMod selection\n\nLimiting scope","description":"How to start planning a pack","url":"/wiki/organization/planning/","tags":[]},{"title":"Project Management","content":"Project Management\n\nWorking with mod devs\n\nWorking with others\n\nGetting help \n\nMaintaining motivation\n\nPlaytesting","description":"Mmm projkect","url":"/wiki/organization/project-management/","tags":[]},{"title":"Marketing","content":"Marketing\n\nMarketing a modpack is not a simple task. Don't do it.\n\nModpack page \n\nGetting feedback","description":"Notes on how to build an audience for your pack","url":"/wiki/organization/marketing/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/regex/","tags":["todo"]},{"title":"Neo/Forge data loading conditions","content":"Neo/Forge data loading conditions\n\nBoth Forge and Neoforge have additional datapack functionality where both modders and modpack developers can dynamically disable/enable data files based on given criteria. These criteria can range from checking if a tag/item exists in the registry, or simply disabling the file outright.","description":"Overview on Neo/Forge's data loading conditions and how to use them","url":"/wiki/info/neoforge-data-conditions/","tags":[]},{"title":"mcmeta filter","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/mcmeta-filtering/","tags":["todo"]},{"title":"Free Multiplayer","content":"Free multiplayer options for modded Minecraft\n\nMod options\n\n| Mod| Versions| Pros | Cons| Additional notes |\n| ----------------------------------------------------------------------- | ----------------- | ---- | ------------------ | ---------------- |\n| e4mc| 1.17 -> 1.21.11|| Reliability issues ||\n| Cloudflared | 1.7.10 -> 1.20.4||||\n| Tunnely| 1.19.2 -> 1.21.10 ||||\n\nOracle Free Tier\n\nOracle Free Tier is a service offered by the Oracle corporation to offer free 24GB servers to users who apply. The catch is that it's more time and effort to set up and maintain than any of the mods shown here, since you'd be setting up an unmanaged Linux server to play Minecraft from scratch. However, some online guides do exist to aid through the process.\n\nServer host partnership\n\nIf you are already an established developer in the community, you may want to consider looking into a server sponsor partner. Sponsors often give out servers to their partners for free, and most eligible creators could find themselves getting a 6-8GB server out of a partnership.\n\nAternos\n\nAternos is a server host that provides free servers","description":"Exploring options for free multiplayer in modded Minecraft","url":"/wiki/info/free-multiplayer/","tags":["info","multiplayer","free","server"]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/useful-terms/kitchen-sink/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/useful-terms/worldgen-structure/","tags":[]},{"title":"Tag definition","content":"Tags\n\nTags act as references to groups of registry entries, letting Minecraft treat multiple items, blocks, or entities as a single category. For example, the tag #minecraft:logs represents all log blocks, so commands or recipes using that tag automatically apply to oak logs, birch logs, and any other block included in it. Tags are one of the most powerful data pack features for organizing and modifying game behavior without editing core files.\n\nMore information on tags: https://minecraft.wiki/w/Tag_(Java_Edition)","description":"placeholder","url":"/wiki/info/useful-terms/tags/","tags":[]},{"title":"MissingNo.","content":"Header\n\nThis article is not written yet...","description":"placeholder","url":"/wiki/info/useful-terms/vanilla+/","tags":[]},{"title":"Worldgen feature definition","content":"Feature\n\nWorldgen features are decorators generated in each chunk after terrain generation, such as ores, grass, and trees. They differ from structures in that they are usually smaller and generate dynamically based on","description":"placeholder","url":"/wiki/info/useful-terms/worldgen-feature/","tags":[]},{"title":"Licenses (WIP)","content":"Licenses\n\nLicenses are ways for developers to define what others can or cannot do with their work. Licenses can be applied to nearly everything, but Mods, Modpacks, and Resource Packs are the most relevant here. You should be aware of a projects license if you choose to do any of the following:\nDistribute the project on a hosting site that the original work is not hosted on\nUse any part of the projects assets or code in any way, besides simply including it in a modpack\nPort or fork the project \n\n\n\nNo matter what a project's license says, if it is hosted on a platform such as Curseforge or Modrinth, you are free to include it in a modpack as long as it is hosted on the same platform. \n\n\n\nCommon Licenses\n\nMIT\n\nAll Rights Reserved / ARR\n\nLGPL","description":"An overview of common licenses, what they mean, and which one is right for you","url":"/wiki/info/licenses/","tags":["todo"]},{"title":"Custom World Generation","content":"Custom World Generation\n\nCustom World Generation is an experimental feature, allowing a data pack to\ngenerate custom features, biomes, or dimensions, primarily by way of a series of\nJSON files rather than by using commands.\n\nThis guide goes over how to create every step of a custom dimension, which\nitself comprises all of the following. If you only want to achieve one or some\nof these things, you can generally skip to those respective sections.\n\nModifying and defining dimension settings\nGenerating terrain\nCreating biomes\nArranging biomes\nCreating features (ores, trees, etc.)\nMany sub-tasks related to the above\n\nAt the same time, this documentation will express some of the major limitations\nthat come with Custom World Generation. There are many aspects of worldgen that\nwe will go over here in brief, but that could fill entire guides of their own to\nexplore in detail. Many of the tasks involved in creating Custom World\nGeneration can be extremely time-intensive and require a lot of trial and error.\n\nWhat is Custom World Generation?\n\nCustom Worldgen can take the form of anything from a completely separate\ndimension, an override of vanilla dimensions or biomes, like the Overworld at\nlarge or Swamps in particular, or individual features that are placed via\ncommands. The following are all things that Custom World Generation can include,\nirrespective of difficulty.\n\nCustom Terrain\nCustom Dimension Settings, such as:\nUltrawarm\nPiglin zombification\nRespawn Anchors vs Beds\nLight level\nDaylight cycle (on/off)\netc.\nCustom Biomes (Surface and Cave)\nNatural features (Trees, ores, flowers, etc.)\nCustom colors and ambient particles\nCustom Biome layout (including of vanilla biomes)\n\nCustom Structures, and changes related to structures, are also a sub-feature of\nCustom World Generation. We already have documentation for creating Custom\nStructures, which you can find\nhere.\n\nFolder Structure\n\nTo begin creating a Custom Dimension, there are a few folders you should create\nin a data pack. If you’re unfamiliar with the general structure of a data pack,\nyou should check out our Data Pack Starter Guide.\n\nIn your namespace folder, you will create the following folders, organized as\nsuch:\n\n/\n├── dimension/\n├── dimension_type/\n└── worldgen/\n├── biome/\n├── configured_carver/\n├── configured_feature/\n├── density_function/\n├── noise/\n├── noise_settings/\n└── placed_feature/\n\nYou may not need all of these folders depending on the degree of configurability\nyou want or the scope of your project, so which folders are needed or optional\nfor any particular task will be listed at the top of each section.\n\nBecause Custom World Generation requires so many different JSON files, many with\na variety of required vs. optional fields, it is strongly recommended that you\ngenerate most or all of these files using\nMisode’s generators. Furthermore, frequent\nreference to the wiki pages for\ncustom dimensions and their respective subcategories will likely be necessary,\nif only to determine what type of data some fields are expecting, when Misode or\nthis guide do not specify.\n\n\n\nSome popular VSCode extensions may falsely inform you that certain files you\nreference don’t exist or are in the wrong folder, when in fact they are,\ndepending on the version you are working in. This is most common for\nconfigured_features, but be on the lookout for this behavior elsewhere.\n\n\n\nDimension Type\n\nFolders: dimension_type\n\nWhen creating a new dimension, or modifying an existing one, it’s recommended to\nstart with the Dimension Type. The Dimension Type is what defines the very broad\ndetails about the dimension, such as whether water evaporates instantly like the\nNether (Ultrawarm), whether Beds and/or Respawn Anchors work or explode, and\nwhat light level Hostile Mobs need to spawn. Most of these fields are self\nexplanatory, and most of them are required.\n\ndimension_type/overworld.json\n\n{\n\"ambient_light\": 0.0,\n\"bed_works\": true,\n\"coordinate_scale\": 1.0,\n\"effects\": \"minecraft:overworld\",\n\"has_ceiling\": false,\n\"has_raids\": true,\n\"has_skylight\": true,\n\"height\": 384,\n\"infiniburn\": \"#minecraft:infiniburn_overworld\",\n\"logical_height\": 384,\n\"min_y\": -64,\n\"monster_spawn_block_light_limit\": 0,\n\"monster_spawn_light_level\": {\n\"type\": \"minecraft:uniform\",\n\"max_inclusive\": 7,\n\"min_inclusive\": 0\n},\n\"natural\": true,\n\"piglin_safe\": false,\n\"respawn_anchor_works\": false,\n\"ultrawarm\": false\n}\n\nTo create this, simply add a .json file to the dimension_type folder, and set\nthe name to that of the dimension you are creating/modifying. Like all file\nnames, it must have no capital letters, and no special characters except\nunderscores. Then generate the list of fields with\nMisode.\n\nNote that some fields, like “has ceiling”, don’t do what you would expect – this\nfield doesn’t actually give the dimension a physical ceiling, that’s handled in\nthe terrain. Similarly, “Effects” pretty much just changes the skybox and\ndetermines whether the time affects the light level.\n\nNoise Settings\n\nFolders: noise_settings\nOptional Folders: density_function, noise\n\nThe Noise Settings are one of the largest files you will create. This single\nfile per dimension controls all of the following:\n\nWhat base block the dimension’s terrain is made of (Stone, Netherrack, etc.)\nWhat base fluid is used for the sea level (Water, Lava, etc. Does not need to\nbe a fluid)\nSome global settings, such as:\nWhether “Creatures” (passive mobs) spawn during chunk generation\nBiome noise parameters that the worldspawn is allowed to be set in during\nworld creation\nWhether large ore veins generate, and their general size and shape via\nDensity Functions. Only applies to Copper and Iron veins\nWhether aquifers generate. Not configurable beyond true/false. If false,\nmost caves below sea level will be filled with the base fluid.\nNoise Router (The shape of the terrain, which is determined by a few further\nfields)\nSurface Rules (What blocks the surface is made up of, typically broken down by\nbiome)\n\nNote that the sea level also determines the level that caves become filled with\nLava, so a higher sea level will also raise the cave Lava level, and a deeper\nworld with a default sea level will result in all caves being filled with lava\nbelow the same point (about Y=-50).\n\nNoise Router (Terrain)\n\nThe Noise Router is responsible for most factors relating to the terrain, which\nis to say, whether a given block is air/fluid or the default_block, before\nsurface_rules or biome features are added. In addition, the Noise Router\nincludes several fields that don’t directly influence the terrain, but may\napproximate it for use in making biome distribution conform to the terrain.\n\nThe Noise Router contains several fields. All of these fields are density\nfunctions, which can be defined in-line or referenced from the density_function\nfolder. These are essentially formulas of variable length and complexity, that\nuse a variety of functions to determine a value between 0 and 1 for every\ncoordinate. For density functions that affect terrain, this determines whether\nthe block is air/fluid (respecting sea level), or the default_block,\nrespectively.\n\nLet’s look at what each of these density functions are responsible for.\n\nbarrier, fluid_level_floodedness, fluid_level_spread\n\nThese all relate to some facet of Aquifer generation, if they are enabled.\n\nlava\n\nUsed to determine whether an aquifer is lava or not. Does not affect the lava\nthat floods the bottom of the world.\n\nvein_toggle, vein_ridged, vein_gap\n\nUsed to control the shape, density, and rarity of both Iron and Copper Large Ore\nVeins. Cannot change what these blocks are made of, but whether the vein is\nCopper or Iron is based on the vein_toggle noise range.\n\ntemperature, vegetation\n\nCorrespond to the “temperature,” and “humidity,” parameters in the dimension’s\nbiome source, respectively. Ostensibly create the noise maps that biomes are\nplaced relative to. These density functions don’t affect terrain at all.\n\ncontinents, erosion, depth, ridges\n\nCorrespond to the “continentalness,” “erosion,” “depth”, and \"weirdness\"\nparameters in the dimension’s biome source, respectively. Like the temperature\nand vegetation density functions, whatever is put in these fields will not\ndirectly affect terrain, and ostensibly just create noise maps for the biome\nsource to use. However, in the vanilla overworld, these fields are used to\nreference separate density function files that also get referenced elsewhere, to\ninform the terrain. This means that unlike the temperate and vegetation density\nfunctions, these correspond to certain parts of the terrain.\n\nFor example, high erosion parameter values match up with where the terrain is\nmore flat, because of how it gets referenced by other density functions that\nimpact terrain.\n\n\n\nTemperature and vegetation are also all capable of behaving more like\ncontinents, erosion, and depth, but it’s generally not necessary to have so many\nparameters that conform to terrain, and can in fact make biome distribution\nharder and more time consuming.\n\n\n\ninitial_density_without_jaggedness\n\nUsed for aquifers and surface_rules, in order to more accurately determine where\nthe surface of the world is so that neither can generate above that surface.\nTypically, will be similar to the final_density, but with the surface slightly\nlowered, and with noise caves unaccounted for. Similar to the above few\nfunctions, it does not affect terrain at all.\n\nfinal_density\n\nThis is the density function that actually creates the bulk of the terrain. As\nsuch, it’s often the largest and most complex part of the noise_settings file,\nbarring surface_rules. It controls not only the surface, including hills,\nmountains, valleys, and oceans, but also the large noise caves and noodle caves\nintroduced in the Caves and Cliffs update. And, as alluded to above, you still\nneed at least the continents and erosion density functions to align with the\ngeneral shape of this density function if you plan to have ocean biomes generate\nonly where the terrain dips below sea level, or mountain biomes generate only\nwhere the terrain spikes up to look like mountains.\n\nIn the\nvanilla Overworld,\nthe final_density is split into two distinct parts: The part that handles the\nshape of the surface, including mountains, hills, rivers, and oceans; and the\npart that handles the large noise caves underground. These are separated by an\nin-line range_choice density function.\n\nDensity functions are very complex, and being very math-heavy, difficult to dive\ninto and learn about; an in-depth understanding of them and how to apply them is\noutside the scope of this guide. Generally, a lot of trial and error is\nrequired, and there are minimal resources for getting particularly good at\napplying them. These are primarily\nthe wiki page which lists them all\nand what they do to the inputs/arguments,\nthis brief tutorial\nwritten by Misode and now hosted on the wiki, which explains how the Final\nDensity affects the terrain, and provides some basic steps to manipulate it, and\nof course\nMisode’s generator to help\nvisualize individual density functions or chains of them. However, as a brief\nintroduction, this guide will attempt to describe, roughly, how the vanilla\noverworld's final_density applies important density functions to shape the\nworld's surface.\n\nsloped_cheese\n\nUsed as the input in the aforementioned range_choice density function to\ndistinguish between the surface and underground (for noise caves), as well as\nthe main density function that gets applied to the surface. It multiplies the\ndepth and the jaggedness density functions with the factor density function,\ncombining the various shapes they create into one coherent surface shape.\n\nfactor\n\nContains a complex spline that functionally combines the continents, erosion,\nand ridges_folded density functions. These three on their own are ostensibly\nnoise maps like temperature and vegetation, but this spline translates them into\nterrain. Continents is used to create a transition between high and low terrain,\nwith erosion added to flatten the terrain, and ridges_folded (which just\nreferences ridges with some multipliers) to carve rivers or raise peaks on\nmountains.\n\ndepth\n\nCreates a gradient from the surface of the world down, where the surface and\neverything above it is assigned a value of 0, and ascends towards 1 as the world\nheight decreases. It gets the coordinates of the surface by referencing the\noffset density function.\n\noffset\n\nSimilar to factor, and uses the continents, erosion, and ridges_folded density\nfunctions in a similar way to create a shape similar to the terrain's surface,\nbut slightly offset so that the depth density function doesn't start the\ngradient until a little below the surface (generally).\n\njaggedness\n\nSimilar to factor, and uses the continents, erosion, and ridges_folded density\nfunctions in a similar way to create a more jagged version of the surface shape.\nThis gets diluted some due to being combined with both offset and factor higher\nup the chain, but results in some hills populating flatter areas, which also\nhelps to break up otherwise smooth or flat mountains so they look more natural\nand rolling.\n\nSurface Rules\n\nSurface Rules are what add the surface layers to terrain. This is\nhighly-configurable, but at its most basic level, it’s what decides that the\nground in Forests is made up of Grass Blocks and Dirt, and that Deserts have\nSand and Sandstone. Surface Rules can also allow for different blocks to make up\nthe ground depending on height, steepness, or even based on random noise.\n\nNotably, the Surface Rule also places the Bedrock on the bottom (or top) of the\nworld, and handles the transition from Stone to Deepslate at Y=0. This means\nboth of these features can be edited or removed, and in fact it’s fairly easy to\ndo so compared to handling the actual surface.\n\nCreating surface rules is relatively easy. You’ll start with something like this\nin your Noise Settings:\n\n{\n\"surface_rule\": {\n\"type\": \"minecraft:sequence\",\n\"sequence\": ]\n}\n}\n\nInside the sequence brackets, you can add yet more objects. There are four\ndifferent types:\n\nSequence: Allows you to add a new nested list. Generally, it’s good\npractice to nest sequences inside of a condition that will apply to multiple\nchild conditions or blocks.\nBlock: Defines the block that gets placed. Usually used at the end of a\nseries of conditions.\nBandlands: Not a typo. Just places the hardcoded Badlands terracotta\npattern, and doesn’t have any additional fields.\nCondition: This is the most prominent part of Surface Rules. There are\nmultiple kinds of conditions, including biome, Y level, steep, and more.\nRegardless of the condition you select, it will always have the additional\nfield “then run”, which just accepts another object type from the above list.\n\nYou may find yourself using combinations of conditions, with or without\nsequences, to get a satisfying surface. This guide won't go over every surface\nrule condition, but here are some common ones and how they are often used.\n\nabove_preliminary_surface\n\nUses the initial_density_without_jaggedness density function to determine where\nthe surface of the world is. Not using this would just mean that the surface\nrule would apply in noise caves as well. If you’re not using an\ninitial_density_without_jaggedness density function, there’s no other real harm\nin choosing not to use this condition.\n\nstone_depth\n\nThis condition finds the blocks that are actually on the surface via heightmap,\nignoring water, and works even if there was no preliminary surface condition\nused. This is one of the most common conditions, in that every dimension will\nuse it, but it is also a fairly resource-intensive condition, and the one most\nlikely to cause chunk generation lag. It’s best to use it minimally, as high up\nin the Surface Rule as you can. Oftentimes, you will need at least two of these:\nOne for the top surface, and one for the secondary surface.\n\nwater\n\nCan be used to have its child conditions apply based on the fluid level at that\nlocation, including not being in fluid. The vanilla Overworld surface rule uses\nthis a lot, and it’s a great way to alleviate the impact of an earlier\nstone_depth condition.\n\nbiome\n\nSpecifies which biome(s) to apply the rest of the rule to.\n\ny_above\n\nCauses the rest of the rule to only apply to blocks above the specified Y value.\nYou can add an optional multiplier for this value, or choose to add the\nstone_depth from previous conditions to this calculation.\n\nIt’s best to look at how the Overworld’s surface rule uses combinations of\nconditions to produce a surface of, for example, Grass Blocks with 2-4 layers of\nDirt underneath. The vanilla Overworld Surface Rule is not as extreme as the\nvanilla Overworld Dimension file (up next), but it is a little more lengthy and\nsophisticated than can reasonably be pasted here.\n[Misode’s generator has a\nfeature to view the vanilla Overworld Noise Settings as a preset, which includes\nthe Surface Rule; this may be useful to get a more user-friendly view of how the\nconditions fit together.\n\nDimension\n\nFolders: dimension\n\nThe Dimension file is where you reference both the Dimension Type and Noise\nSettings you would like this dimension to use by their namespaced ID. The name\nof this file is also what will become the namespaced ID of this dimension for\ncommands such as /execute in, regardless of the names of the noise_settings or\ndimension_type files referenced. Lastly, this is where you will list all of the\nbiomes you want to appear in the world, using parameters to define which biomes\ncan appear where on several noise maps.\n\nBiome Source\n\nBesides Terrain, the Biome Source is where you may find yourself spending the\nmost time. It is highly configurable, and has the potential to integrate with\nthe Continents and Erosion density functions defined in the Noise Router to help\nplace biomes in a way that appears to conform to the terrain (Mountain biomes on\nelevated terrain, Plains biomes on flatter terrain, etc.). Biome Layout is much\nmore approachable than terrain in terms of configurability, but making them work\nhand-in-hand in this way can be time consuming.\n\nTo put things in perspective, you may have noticed above that the vanilla\nOverworld’s Dimension file is over 200,000 lines long. Every biome has dozens of\nrepeat entries, each with slightly different parameters to get the biome\ndistribution and terrain conformity just right. This is because the six primary\nparameters (temperature, humidity, continentalness, erosion, and depth)\nbasically work to create a 6-dimension noise map. Making a biome source that\nplaces biomes according to terrain by hand is borderline impossible, and indeed,\nthis file gets generated by the game using a system similar to\nSnowcapped, a tool by jacobsjo that uses\ngrids to simplify the visualization of a 6D grid.\n\nThe Nether is far easier to work with and add new biomes to, as those biomes do\nnot conform to the terrain, and each vanilla biome has only one entry.\n\nThe End’s biome source is hardcoded; this is because Mojang needs to ensure that\nthe central End Island is always the default “minecraft:the_end” biome, which\ncannot be guaranteed with current tools. However, if you don’t mind making the\ncentral End Island a different biome, you can approach a custom biome layout\nsimilarly to how you would the Nether.\n\nFor a custom dimension, the complexity is up to you. If you aim to have your\nbiomes conform to terrain, then you may end up with a biome layout of comparable\ncomplexity and time commitment to the vanilla Overworld’s. If not, then it’s\njust a matter of determining which biomes you do or do not want to appear next\nto each other, and then setting the parameters appropriately.\n\nEach entry in the “biomes” list should look something like this:\n\n{\n\"biome\": \"minecraft:plains\",\n\"parameters\": {\n\"temperature\": -0.45, -0.15],\n\"humidity\": [-1, -0.35],\n\"continentalness\": [-0.11, 0.3],\n\"erosion\": [-0.7799, -0.375],\n\"weirdness\": [-1, -0.9333],\n\"depth\": 0,\n\"offset\": 0\n}\n}\n\nMore biomes can be added by including more entries in the “biomes” list. It can\nand often may include repeats. Each entry must also contain all of the\nparameters listed above. Unless otherwise specified, all of these parameters can\neither be a single constant, or a list of two constants, which serves as a min\nand max range of values. These must be in order from min to max; failure to do\nso will cause the data pack to not validate.\n\ntemperature, humidity\n\nThese are named completely arbitrarily, and have no bearing on the actual\ntemperature or humidity of the biome that impacts gameplay in any way. You can\nmake both a “desert” and “snowy” biome have a temperature of 0, and all it will\nmean is that they will be placed near each other (unless other parameters forbid\nthis). These parameters just refer to different noise maps that are available.\nThese should each be a value between -1.0 and 1.0. The closer a value is to 0,\nthe more frequently that biome will appear, or the larger.\n\ndepth\n\nUsed exclusively for cave biomes, and is otherwise 0. Positive values cause that\nbiome to be placed deeper in the world, and the area above it to be filled with\nother biomes of lower depth values that meet the other parameters of that space.\nIn the vanilla depth density function, a depth of 1.0 corresponds to\napproximately 128 blocks below the surface, but this can vary if you've changed\nthe Final Density or the depth density function in your Noise Router.\n\noffset\n\nHelps to limit the relative size of the biome. Accepts a value between 0 and\n1.0, and must be a single constant, not a list. Larger values reduce the size of\nthe biome, and allow biomes of neighboring parameter values to fill the space.\nThis can also result in the biome becoming rarer, if it was already small enough\nthat a positive offset causes some of its placements to disappear.\n\nweirdness\n\nThis parameter corresponds to the ridges density function, which is responsible\nfor rivers and mountain peaks. Values closer to 0 tend to correspond to rivers,\nand values further from 0 tend to correspond to peaks, before dipping back to\nmore level terrain. The vanilla overworld also uses this parameter to place\n\"variant\" biomes like Bamboo Jungles or Pale Gardens, which otherwise might\nshare similar parameters to their base biomes (Jungles and Dark Forests)\n\ncontinentalness, erosion\n\nThese are the two parameters that influence a biome’s placement on the density\nfunctions of the same names used for Terrain. In the vanilla Overworld, only\nthese values will affect biome position relative to the shape of the terrain.\nFor the vanilla Overworld:\n\nHigh continentalness corresponds to inlands terrain.\nLow continentalness corresponds to ocean terrain.\nHigh erosion corresponds to flat terrain.\nLow erosion corresponds to jagged terrain.\n\nThe above rules may not necessarily hold true if you have a Final Density that\ndiffers from the vanilla Overworld.\n\nThe best way to view and manipulate the biome source and how it may look in the\nworld is with [Misode’s generator.\nHowever, it may not show completely accurate biome placement if you are taking\nadvantage of continentalness and/or erosion.\n\nBiomes\n\nFolders: biome\nOptional Folders: configured_carver, placed_feature,\nconfigured_feature\n\nThis is where the most configurability and excitement, and least limitations,\ncomes into play. Biomes are really just designated areas that can have the\nfollowing things defined:\n\nPrecipitation (True/False)\nTemperature\nUsed to determine rain or snow if Precipitation is true\nAlso influences natural grass and foliage coloration, along with Downfall\nOverride colors for grass, foliage, sky, fog, water, and water fog\nFor grass and foliage, this color is added to the color determined by\nTemperature and Downfall, which references the respective colormaps in the\nResource Pack.\nParticles, if any (such as in many Nether biomes)\nMusic and ambient sounds\nCave and canyon (ravine) types\nNaturally spawning mobs\nFeatures\n\nNot all of these need to be defined, but they all need to be present, even if\nempty. As always, it’s best to use\nMisode’s generator to ensure all\nrequired fields are accounted for. It also has useful tools for selecting\ncolors, where appropriate.\n\n\n\nIf you are modifying a vanilla biome (or a biome from another mod or data pack),\nyour biome will necessarily be incompatible with any other data packs that\nmodify that biome, too. This means you can’t, for example, add more Diamonds to\nthe vanilla Swamp biome, and then also include Terralith -- you would need to\ninstead use Terralith’s Swamp biome as a base and add more diamonds to that, if\nyou want to use both in the same world.\n\n\n\nNaturally Spawning Mobs\n\nCalled “Spawners” (not confusing at all), this is what decides what mobs will\nspawn in this biome, at what rarities and in what quantities.\n\n\n\nThis does not dictate those mobs’ spawning conditions–for the most part, we\ncan’t change that. Passive Mobs will always need Grass Blocks and light to\nspawn, and Hostile Mobs will still need a low enough light level as defined in\nthe Dimension Type. Some mobs, like Sniffers and Camels, don’t have as strict\nspawning conditions because they don’t spawn naturally in vanilla. This means\nthey can spawn anywhere in the biome, even if it doesn’t make sense.\n\n\n\n{\n\"spawners\": {\n\"ambient\": \n{\n\"type\": \"minecraft:bat\",\n\"maxCount\": 8,\n\"minCount\": 8,\n\"weight\": 10\n}\n],\n\"axolotls\": [],\n\"creature\": [\n{\n\"type\": \"minecraft:sheep\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 12\n},\n{\n\"type\": \"minecraft:pig\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 10\n},\n{\n\"type\": \"minecraft:chicken\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 10\n},\n{\n\"type\": \"minecraft:cow\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 8\n},\n{\n\"type\": \"minecraft:horse\",\n\"maxCount\": 6,\n\"minCount\": 2,\n\"weight\": 5\n},\n{\n\"type\": \"minecraft:donkey\",\n\"maxCount\": 3,\n\"minCount\": 1,\n\"weight\": 1\n}\n],\n\"misc\": [],\n\"monster\": [\n{\n\"type\": \"minecraft:spider\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 100\n},\n{\n\"type\": \"minecraft:zombie\",\n\"maxCount\": 4,\n\"minCount\": 4,\n\"weight\": 95\n}\n]\n}\n}\n\nSpawners are defined by first opening up a list of one of several categories,\nsuch as Monster, Creature, Water Ambient, or Axolotl. You can make mobs spawn in\nwhatever category you want, but if you put it in the wrong category than it\nbelongs (generally, Creature for passive mobs, Monster for hostile mobs, etc.),\nthey may either fail to spawn entirely, or overspawn and exceed the mobcap. For\nthis reason, it is advised that you only spawn mobs in their correct category;\nif you don’t know which it belongs to, refer to a vanilla biome that spawns that\nmob and see where it’s placed.\n\nAn individual mob spawner entry includes the mob type, its weight (which works\njust like loot tables) and a min and max count. These latter values determine\nhow many mobs will spawn within a group as one successful spawn attempt of that\nmob type. The min must be greater than 0.\n\nSpawn Costs\n\nSpawn Costs are an optional field within the biome file, and are used to limit\nthe frequency of spawns around mobs of a certain type, within that biome only.\nIn vanilla, this is used to limit the number of Endermen that appear in Warped\nForests, and Skeletons that appear in Soul Sand Valleys.\n\n{\n\"spawn_costs\": {\n\"minecraft:enderman\": {\n\"charge\": 1.0,\n\"energy_budget\": 0.12\n}\n}\n}\n\nA Spawn Cost for an individual mob consists of an energy_budget, and a charge,\nwhich are both float values. These are a little hard to explain, but\nessentially, the “charge” is used to calculate an individual mob’s contribution\nto the overall “energy budget” shared by all mobs of that type in the biome. If\nthe value calculated from that charge would exceed that energy budget, it fails\nto spawn. This is very simplified, and indeed somewhat unintuitive, as the\ncharge will generally be higher than the energy budget.\n\nIf you’d like to learn more about how this works, see the wiki entry relating to\nit [here.\n\nCarvers\n\nThis is where the legacy caves and ravines are defined for the biome. They are\nsplit into two steps: air and liquid, which behave as you would expect; either\nproducing regular air caves, or flooded caves.\n\nYou can define custom caves or canyons with a configured_carver, including\ndefining what types of blocks the cave will be allowed to replace (which is why\nit’s called a carver), their frequency, size, and other values. To explore this\nfully, it’s recommended to mess with the various fields using\nMisode’s generator.\n\nFeatures\n\nFeatures are the real meat of a biome. These are everything that actually fills\nup the biome and gives it character beyond the terrain and surface. Trees,\nflowers, ores, geodes, granite deposits, and sometimes small structures like\nDesert Wells are all features. There is a lot you can do here, but the options\naren’t limitless.\n\nFor one, there’s the issue of performance. Larger and more common features make\nloading new chunks slower, as do features that have hyper-specific location\nrequirements to spawn.\n\nFor two, some specific shapes are harder to achieve, and some common features\naren’t as configurable as others. Trees are some of the most configurable\nfeatures in the game, able to use any block or combination of blocks for their\ntrunks, leaves, roots, and more, and can be used to make elaborate shapes and\nfeatures that don’t even look like trees. Conversely, the coral reefs in Warm\nOceans are easy to replicate and adjust the frequency and location of, but their\nshapes and the blocks they’re made of cannot be changed at all.\n\nAs such, it’s often better to have some broad strokes for the “feel” or\natmosphere you want for a biome in mind, rather than planning everything down to\nthe shape, as flexibility may be necessary.\n\n{\n\"features\": \n[],\n[\"minecraft:lake_lava_underground\", \"minecraft:lake_lava_surface\"],\n[\"minecraft:amethyst_geode\"],\n[\"minecraft:monster_room\", \"minecraft:monster_room_deep\"],\n[],\n[],\n[\n\"minecraft:ore_dirt\",\n\"minecraft:ore_gravel\",\n\"minecraft:ore_granite_upper\",\n\"minecraft:ore_granite_lower\",\n\"minecraft:ore_diorite_upper\",\n\"minecraft:ore_diorite_lower\",\n\"minecraft:ore_andesite_upper\",\n\"minecraft:ore_andesite_lower\",\n\"minecraft:ore_tuff\",\n\"minecraft:ore_coal_upper\",\n\"minecraft:ore_coal_lower\",\n\"minecraft:ore_iron_upper\",\n\"minecraft:ore_iron_middle\",\n\"minecraft:ore_iron_small\",\n\"minecraft:ore_gold\",\n\"minecraft:ore_gold_lower\",\n\"minecraft:ore_redstone\",\n\"minecraft:ore_redstone_lower\",\n\"minecraft:ore_diamond\",\n\"minecraft:ore_diamond_medium\",\n\"minecraft:ore_diamond_large\",\n\"minecraft:ore_diamond_buried\",\n\"minecraft:ore_lapis\",\n\"minecraft:ore_lapis_buried\",\n\"minecraft:ore_copper\",\n\"minecraft:underwater_magma\",\n\"minecraft:disk_sand\",\n\"minecraft:disk_clay\",\n\"minecraft:disk_gravel\"\n],\n[],\n[\"minecraft:spring_water\", \"minecraft:spring_lava\"],\n[\n\"minecraft:glow_lichen\",\n\"minecraft:patch_tall_grass_2\",\n\"minecraft:patch_bush\",\n\"minecraft:trees_plains\",\n\"minecraft:flower_plains\",\n\"minecraft:patch_grass_plain\",\n\"minecraft:brown_mushroom_normal\",\n\"minecraft:red_mushroom_normal\",\n\"minecraft:patch_pumpkin\",\n\"minecraft:patch_sugar_cane\",\n\"minecraft:patch_firefly_bush_near_water\"\n],\n[\"minecraft:freeze_top_layer\"]\n]\n}\n\nBest practice is to have the “features” section of your biome consist of 11\nlists (defined with square brackets: [ ]), called “steps”, but you can have any\nnumber of steps, fewer or greater. Generally, features will be placed in order\nbased on which step they appear in, from top to bottom. So, if you want to place\nTree features with leaves made of Stone, and then place Ore features that get\nplaced in the stone, you would put those features in separate steps, with the\nOre feature in a later step from the Tree.\n\nOther parts of the game refer to these steps by name, representative of the\norder they generate in, specifically for things like Custom Structure Generation\nto reference which step of generation those should appear in. However, the names\nthemselves are arbitrary and just reflect which steps vanilla chooses to put its\nfeatures in; any feature type can go in any step. For interest’s sake, these\ndesignations are, in order from first step to last:\n\nRAW_GENERATION: Where End biomes place the small circular endstone\nislands\nLAKES: Where Overworld biomes place lava lakes, and used to place water\nlakes\nLOCAL_MODIFICATIONS: Where Overworld Biomes place Amethyst Geodes, and\nthe Frozen Ocean biome places Icebergs\nUNDERGROUND_STRUCTURES: Where Overworld Biomes place Dungeons and Fossils\nSURFACE_STRUCTURES: Where the Desert biome places Desert Wells\nSTRONGHOLDS: No vanilla biomes place features here, but you can and it’ll\nwork fine\nUNDERGROUND_ORES: Where all Overworld biomes place ores (which includes\nactual ore blocks, as well as the blobs of Dirt, Gravel, and Stone variants),\nas well as discs that generate on the floor underwater\nUNDERGROUND_DECORATION: Where all Nether biomes place ores (which\nincludes actual ore blocks, as well as the blobs of Gravel and Blackstone),\nand where Overworld mountain biomes place blobs of Infested Stone\nFLUID_SPRINGS: Where all Overworld and Nether biomes place water and/or\nlava springs (individual fluid blocks that may or may not spill out of walls\nor ceilings)\nVEGETAL_DECORATION: Where all biomes place features such as trees,\nflowers, cacti, Huge Fungi, Chorus Plants and similar features\nTOP_LAYER_MODIFICATION: Where all Overworld biomes place a feature that\ncauses snow or ice to cover the top blocks if the temperature is\nsufficiently low at that altitude\n\nNote that there are some exceptions to generation order. For example, Deltas\nwill generally spawn after everything else regardless of which step they’re\nplaced in. Conversely, Lakes often spawn before other features, even if they are\nin a later step.\n\n\n\nIf you have two or more features that appear in one step together (regardless of\nwhich step it is) in multiple biomes, they must always be in the same order, or\nthe game will throw an error and fail to load (this is called a feature order\ncycle error). For the same reason, you can't repeat a feature in the same step,\neven one after the other, if that feature is used in a different biome.\n\n\n\nFeatures are themselves composed of two other file types: placed_features, and\nconfigured_features. A configured_feature defines what type of feature it is,\nphysically, such as an ore or a tree. The placed_feature determines under what\nconditions it spawns, such as in or on what blocks, at what Y level, or other\nfactors. The placed_feature is what the biome file references.\n\nTechnically, the configured_feature can be defined in-line in the\nplaced_feature, however it’s good practice to separate these files. This allows\neasier delineation when creating and editing -- as some configured_feature types\ninclude in-line placements like a placed_feature -- and also makes it easier to\nreuse a configured_feature in multiple placed_features.\n\nConfigured Features\n\nThere are many configured_feature types, each with different required fields.\nListing each in detail would be unhelpful, outside the scope of this guide, and\na duplication of efforts --\n[the wiki serves as a great\nreference to become familiar with the available feature types. As always,\nutilizing Misode to keep track of\nrequired fields is highly recommended. Furthermore, if you do have an idea of a\nvanilla feature that looks similar to what you want to create, referencing it or\nstarting from it as a base, and then modifying it, is a completely valid\nstrategy.\n\nInstead, what this section of the guide will go over is point out which features\nare best for what purpose, and which features are surprisingly difficult to work\nwith, primarily as this knowledge may help keep you from becoming frustrated\nthat you can’t figure out how to do something that is, in fact, not possible.\n\n{\n\"type\": \"minecraft:tree\",\n\"config\": {\n\"decorators\": ],\n\"dirt_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:dirt\"\n}\n},\n\"foliage_placer\": {\n\"type\": \"minecraft:blob_foliage_placer\",\n\"height\": 3,\n\"offset\": 0,\n\"radius\": 2\n},\n\"foliage_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:oak_leaves\",\n\"Properties\": {\n\"distance\": \"7\",\n\"persistent\": \"false\",\n\"waterlogged\": \"false\"\n}\n}\n},\n\"force_dirt\": false,\n\"ignore_vines\": true,\n\"minimum_size\": {\n\"type\": \"minecraft:two_layers_feature_size\",\n\"limit\": 1,\n\"lower_size\": 0,\n\"upper_size\": 1\n},\n\"trunk_placer\": {\n\"type\": \"minecraft:straight_trunk_placer\",\n\"base_height\": 4,\n\"height_rand_a\": 2,\n\"height_rand_b\": 0\n},\n\"trunk_provider\": {\n\"type\": \"minecraft:simple_state_provider\",\n\"state\": {\n\"Name\": \"minecraft:oak_log\",\n\"Properties\": {\n\"axis\": \"y\"\n}\n}\n}\n}\n}\n\nAs mentioned above, some configured_features, like trees, offer a lot of control\nand flexibility. Trees have several different shapes to choose from for their\ntrunks and leaves, as well as optional roots (such as what Mangroves have),\noptions for decorations on any face of leaves, and can accept one or multiple\ndifferent blocks to make up each of these facets.\n\nThe Ore feature type does not have quite as many fields, but still presents a\ngood deal of configurability. Making a new ore configured_feature entails\ndetermining what the block being placed is (the state) and what blocks it tries\nto get placed in (the target), which can be a block tag. As you can see in the\nbelow example for Coal, you can also list multiple state and target pairs in one\nfeature, which vanilla uses to place the appropriate Deepslate variant if the\nblock it gets placed in is a Deepslate or Tuff Block rather than Stone or a\nstone variant.\n\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"discard_chance_on_air_exposure\": 0.0,\n\"size\": 17,\n\"targets\": [\n{\n\"state\": {\n\"Name\": \"minecraft:coal_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:stone_ore_replaceables\"\n}\n},\n{\n\"state\": {\n\"Name\": \"minecraft:deepslate_coal_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:deepslate_ore_replaceables\"\n}\n}\n]\n}\n}\n\nThe size is self-explanatory but is not indicative of the actual quantity of the\nstate blocks that will be placed. More info on that relationship can be found on\nthe [wiki.\nDiscard_chance_on_air_exposure is a chance between 0.0 and 1.0 to intentionally\nfail to spawn the feature if it touches air, such as in a cave. This is used in\nvanilla for so-called “buried” ore features like Iron and Diamonds, to encourage\nother forms of mining than just caving.\n\nThe Ore feature type is also what is used for the blobs of dirt, gravel,\ngranite, tuff, and other blocks in the Overworld.\n\nMoving into feature types that are not configurable and what you can do about\nit. End Islands, Basalt Pillars, Ice Spikes, Glowstone Blobs, and Coral Claws\nare all examples of features that have no configuration at all, meaning their\nshape and block palette is hardcoded. You can still change how they get placed\nwith a placed_feature later, but you can’t change what these features physically\nare.\n\nFor cases like these where you may want to make use of those specific shapes,\nbut can’t recreate them with other features (End Islands are a good example),\nyou can create features to replace those blocks with other blocks in a later\nstep. A good feature to use for this is geodes, because they can define a list\nof blocks that they are not able to replace, which can include all blocks except\nthe desired replaceables.\n\nThis just allows you to replace a target block with a state block in a\n3D-diamond with a defined radius. It unfortunately doesn’t support block tags.\nIt also has a maximum radius of 12, so you may need a higher quantity of them\nusing your placed_feauture later to get consistent coverage.\n\nPlaced Features\n\nA placed_feature typically references a configured_feature, and determines how\nit gets placed in the world. For some features, like Trees, they will obey\nwherever your placements happen to define as valid. For other features, like Ice\nSpikes, they need to adhere to hardcoded conditions of the feature type, which\nare not always obvious. Ice Spikes for example can only spawn on Snow Blocks,\nregardless of what the placed_feature says.\n\nAs with the previous section, this guide will not go over every type of\nplacement that can be included, nor every field they contain. These are all\ncovered in detail on the wiki, and\ngenerating them can be aided using\nMisode.\n\nHowever, there are a handful of placement types that are used extremely\ncommonly, and so we will go over what those are, how to use them, and when they\nmay not be needed.\n\n{\n\"type\": \"minecraft:ore\",\n\"config\": {\n\"discard_chance_on_air_exposure\": 0.0,\n\"size\": 10,\n\"targets\": [\n{\n\"state\": {\n\"Name\": \"minecraft:copper_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:stone_ore_replaceables\"\n}\n},\n{\n\"state\": {\n\"Name\": \"minecraft:deepslate_copper_ore\"\n},\n\"target\": {\n\"predicate_type\": \"minecraft:tag_match\",\n\"tag\": \"minecraft:deepslate_ore_replaceables\"\n}\n}\n]\n}\n}\n\nGenerally, placements are calculated in order from first to last. For some\nplacement types, this is irrelevant, while for others, being listed before or\nafter another placement can dramatically alter the spawning behavior. The\nfollowing placement types are the most commonly used; a majority of\nplaced_features will use some combination of these placements:\n\ncount\n\nThe number of spawn attempts this feature will make per chunk. Accepts a\nconstant, or other number providers like uniform or trapezoid. If excluded, the\nplaced_feature will make only 1 spawn attempt per chunk.\n\ncount_on_every_layer\n\nAn alternative to count. A little hard to explain, but essentially includes some\nrandom X and Z distribution, and Y distribution based on layers of air or fluid.\n\nrarity_filter\n\nAccepts a positive integer. Essentially divides any previous count-type\nplacements by this value. For example, a rarity of 1 will cause no change, a\nrarity of 2 will make the feature half as common, a rarity of 5 will make it 5\ntimes less common, etc. If no count-type placement was specified before this\nplacement, the count is assumed to be 1.\n\nin_square\n\nThis is used to include some random distribution within the chunk. Without this\nplacement, all of the spawn attempts would be made at the chunk’s 0x, 0z\ncoordinate. If you are using count_on_every_layer, you do not need to use\nin_square.\n\nheight_range\n\nDetermines the height this feature will try to spawn in. Accepts a constant, or\nother number providers like uniform or trapezoid. Whether using a constant or a\nnumber provider, each value must also be defined as “absolute” (this exact Y\nlevel), “above_bottom” (this many blocks above the lowest Y level of this\ndimension) or “below_top” (this many blocks below the highest Y level of this\ndimension, always a positive number). This allows some flexibility for\nsituations such as if the height of the dimension may change or is unknown.\n\nheightmap\n\nAccepts one of a few different heightmaps, including MOTION_BLOCKING,\nOCEAN_FLOOR, and WORLD_SURFACE_WG. This causes the feature to attempt to spawn\nat the highest block in the chosen X and Z coordinate, according to the selected\nheightmap. Unsurprisingly, this can cause undesired behavior if the dimension\nhas a roof, like the Nether.\n\nbiome\n\nDoesn’t have any other fields. Ensures that this feature won’t be allowed to\nspawn if the spawn attempt would be inside a biome that does not contain this\nplaced_feature in its listed features. Without it, if a chunk contains two\nbiomes, the feature would be allowed to “bleed” into the neighboring biome, even\nif it doesn’t belong there, as long as all other conditions are met (for\nexample, a Desert’s Cactus feature spawning in an adjacent Beach biome).\n\nblock_predicate_filter\n\nCan be used to apply one or more conditions based on nearby blocks, including\nthe block that has been selected for the spawn attempt. This can include details\nlike if the block below is solid or in a block tag, whether it has a sturdy\nface, or is a valid location for a sapling or mushroom to be placed.\n\nOne of the most important things to keep in mind when creating placed_features\nin particular is performance. More than anything else in worldgen, the\nplaced_features are going to have the greatest impact on the speed of your chunk\ngeneration. Features that have a high count, or hyper-specific\nblock_predicate_filters, can cause chunks to load more slowly. Similarly,\nincluding a height range for a feature that includes a lot of space that the\nfeature can’t spawn in can impact this chunk generation, as all of those failed\nspawn attempts still have to be calculated.","description":"This guide goes over how to create every step of a custom dimension, which includes custom biomes, terrain, and features.","url":"/wiki/worldgen/custom-worldgen/","tags":[]},{"title":"Page Formatting","content":"Page Formatting\n\nLast Updated: 1-31-2025\n\nThis section goes over how we format wiki pages. We like to be consistent, so\nplease read through this section carefully and use these features to your\nadvantage:\n\nBasic Writing Guidelines\n\nWhen writing for the wiki, write in a way that is easy to understand and easy\nfor beginners to understand. Put yourself in the viewer's shoes. _What\nconfused you when you first learned about the topic? What new terms did you\nlearn?_ Avoid using technical terms without explaining them or point to a\nresource that explains them.\n\nDocumentation and tutorials are a great way to learn, but sometimes you don't\nneed to read every part of a page to understand it. When writing for the wiki,\nwrite in a way that makes it easy to scan and understand quickly. Some\nrecommendations are using white space to your advantage to break your page into\neasily digestible chunks.\n\nWhen learning a concept, it is helpful to have concrete examples that people can\nrefer to instead of just using a concept. This will help wiki-goers understand\nthe concept better and make it easier to remember.\n\nWriting Style\n\nThe datapacking community is a diverse group of people with different\nbackgrounds; many people don't speak English as their first language!\n\nWhen writing, try to follow these guidelines:\n\nUse the active voice. For example, instead of\nThe pig is teleported by the command, write\nThe command teleported the pig.\nDon't use unnecessary adverbs or adjectives\nTry not to use the words: _obvious, simple, basic, easy, actual, just,\nclear,_ and however\nExplicitly reference what you are explaining\nUse 's for indicating possession\nUse the Oxford comma\n\nTechnical information\n\nAll content on the website (except a few small exceptions) are made using a\ntechnology called mdsvex. This technology enables people like you to insert\nMarkdown with svelte components.\n\nIt is recommended to know what the proper way to format Markdown is in order to\nstay consistent and prevent confusion.\n\nThe front matter title is the same as the title in the sidebar and the title\non the page (heading 1 or single #)\nUse bold and italics sparingly and only when emphasis is needed\nUse headings to break up the page into sections\nCode blocks are used to show code snippets or commands\nAdmonitions are used to show important information\nunrelated to the content of the page\nTables are used to show large amounts of data\n\nEach page is made of 3 parts:\n\nfront matter (metadata about the page such as title, description, tags,\nversion, etc.)\ncontent (the actual content of the page)\ncomponents (custom components that allow for interactivity or other features\nnot able to be reproduced with markdown)\n\nEach is crucial to making the page look and feel how it does.\n\nFrontmatter\n\nWe try to keep the front matter as minimal as possible, but it is still\nrequired. Without it, the page will not display correctly on search engines or\nother sites. The front matter for this page looks like this:\n\ntitle: \"Site Development\" description: \"This page is meant to be an introduction\nto formatting a page for the wiki. In it is multiple examples which you can\nexamine raw in the site source code.\"\nversion: 1.21.5\n\nFront matter is denoted with triple hyphens (---) at the top of the page and\nthe end of the front matter.\n\nThe title should be the same as the title in the sidebar in order to reduce\nconfusion.\nThe description should be a short summary of the content of the page in\norder to show people what all is covered in the article.\nThe version should be set to the latest version that the page has been and\nworks in. If the page works in 1.21.4 but not in 1.21.5 or later, this should\nbe set to 1.21.4.\n\nCustom Elements\n\nOur markdown system adds unlimited customizability to the way we format our\npages. As of the time of writing, we have the following features:\n\nAdmonitions\nCode Titles\nMCFunction Formatting (Thanks Snave!)\nHighlighting\n\nAdmonitions are a way to warnings, info or tips, or other important information\nto your page.\n\n\n\nThis is an example of an info box.\n\n\n\n\n\nThis is an example of an info box.\n\n\n\nCode blocks are a way to format code in your page. These code blocks come with\nthe option to add a title to the code block for clarity. The Modpack Dev Wiki\nsupports syntax highlighting for MCFunction which are used for code samples\nwhenever possible.\n\nfunction example() {\nconsole.log(\"Hello World!\");\n}\n\nHighlighting is a way to highlight specific text. It isn't commonly used, but\nexists.\n\nHighlighted Text like this.\n\nStandardized Elements\n\nThe wiki uses a few elements that are standardized across the entire wiki. Right\nnow this only consists of command syntax. You can find the command syntax we use\nin the commands page.","description":"This page is an introduction to formatting page content, and details about how the wiki handles formatting.","url":"/contribute/formatting/","tags":[]},{"title":"Git Practices","content":"Git Practices\n\nLast Updated: 12-13-2024\n\nThis page is an introduction to how we use Git in the\nwiki repository. In order to keep the\nwiki consistent and reputable, we have a few rules that we follow.\n\nGit provides a lot of features that are great for collaboration, and we try to\nuse them as much as possible.\n\n\n\nThis guide assumes you already have experience using Git before.\n\n\n\nForking and PRs\n\nForks are a great way to work on the wiki without introducing unfinished pages,\nchanges, etc. to main. You can click the\n\"Fork\" button in the top right\ncorner of the repository to create a fork of the repository. This will create a\ncomplete copy of the repository that you can work on.\n\nOnce you have forked the repository, you can clone it to your local machine.\n\nWhen it comes time to merge your changes, you can create a pull request, and a\nwiki contributor will review your contribution.\n\nBranches\n\nBranches are useful additions to help separate features in your fork. We use\nkebab-case for branch names meaning the branch name should be all lowercase\nwith hyphens to separate words. For example, if you are working on a page called\n\"Adding New Features\", the branch name should be adding-new-features.\n\nWe do not recommend you use branches for the main repository, even if you have\npermissions to. Branches in the repository are mainly for upcoming Minecraft\nversions or huge upcoming reworks, if you believe you have a reason to add a\nbranch to the main repository, let a wiki admin know.\n\nCommit Messages\n\nCommit messages are a great way to keep track of what changes have been made to\nthe wiki. Summarize the changes in the commit message and use the imperative\nmood.\n\nFor example, if you are adding a new page called \"Adding New Features\", the\ncommit message should be Add new page for adding new features. If you are\nfixing a typo on a page, the commit message could be\nFix typo in page about adding new features.\n\nOptionally, you can add a short description of the changes in the commit\nmessage. This is not required, but it is recommended.\n\nMerging\n\nWhenever you start working on a new branch or features, pull the latest changes\nfrom the main branch. This will ensure that you have the most up-to-date\nchanges.\n\nYou will likely run into an issue with the search.json file, which is used to\ngenerate the search index. This file is generated automatically and should not\nbe manually edited. A solution to this is to remove the search.json file and\noptionally run the search index generation script. This will regenerate the file\nand you can commit it.\n\nnode run ./gen_search_indexes_node.js\n\nOR\n\nbun ./gen_search_indexes.js\n\nOther Important Information\n\nMake a description of your changes in your PR.\nReviewers: Proofread changes before approving them.\nReviewers: It's not required, but it's recommended the changes follow American\nEnglish for consistency sake.","description":"This page is an introduction to our Git practices a page for the wiki.","url":"/contribute/git-practices/","tags":[]}]